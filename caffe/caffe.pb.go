// Code generated by protoc-gen-go.
// source: caffe.proto
// DO NOT EDIT!

/*
Package caffe is a generated protocol buffer package.

It is generated from these files:
	caffe.proto

It has these top-level messages:
	BlobShape
	BlobProto
	BlobProtoVector
	Datum
	FillerParameter
	NetParameter
	SolverParameter
	SolverState
	NetState
	NetStateRule
	ParamSpec
	LayerParameter
	TransformationParameter
	LossParameter
	AccuracyParameter
	ArgMaxParameter
	ConcatParameter
	ContrastiveLossParameter
	ConvolutionParameter
	DataParameter
	DropoutParameter
	DummyDataParameter
	EltwiseParameter
	ExpParameter
	HDF5DataParameter
	HDF5OutputParameter
	HingeLossParameter
	ImageDataParameter
	InfogainLossParameter
	InnerProductParameter
	LRNParameter
	MemoryDataParameter
	MVNParameter
	PoolingParameter
	PowerParameter
	PythonParameter
	ReLUParameter
	SigmoidParameter
	SliceParameter
	SoftmaxParameter
	TanHParameter
	ThresholdParameter
	WindowDataParameter
	V1LayerParameter
	V0LayerParameter
	PReLUParameter
*/
package caffe

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Phase int32

const (
	Phase_TRAIN Phase = 0
	Phase_TEST  Phase = 1
)

var Phase_name = map[int32]string{
	0: "TRAIN",
	1: "TEST",
}
var Phase_value = map[string]int32{
	"TRAIN": 0,
	"TEST":  1,
}

func (x Phase) Enum() *Phase {
	p := new(Phase)
	*p = x
	return p
}
func (x Phase) String() string {
	return proto.EnumName(Phase_name, int32(x))
}
func (x *Phase) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Phase_value, data, "Phase")
	if err != nil {
		return err
	}
	*x = Phase(value)
	return nil
}
func (Phase) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// the mode solver will use: 0 for CPU and 1 for GPU. Use GPU in default.
type SolverParameter_SolverMode int32

const (
	SolverParameter_CPU SolverParameter_SolverMode = 0
	SolverParameter_GPU SolverParameter_SolverMode = 1
)

var SolverParameter_SolverMode_name = map[int32]string{
	0: "CPU",
	1: "GPU",
}
var SolverParameter_SolverMode_value = map[string]int32{
	"CPU": 0,
	"GPU": 1,
}

func (x SolverParameter_SolverMode) Enum() *SolverParameter_SolverMode {
	p := new(SolverParameter_SolverMode)
	*p = x
	return p
}
func (x SolverParameter_SolverMode) String() string {
	return proto.EnumName(SolverParameter_SolverMode_name, int32(x))
}
func (x *SolverParameter_SolverMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SolverParameter_SolverMode_value, data, "SolverParameter_SolverMode")
	if err != nil {
		return err
	}
	*x = SolverParameter_SolverMode(value)
	return nil
}
func (SolverParameter_SolverMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

// Solver type
type SolverParameter_SolverType int32

const (
	SolverParameter_SGD      SolverParameter_SolverType = 0
	SolverParameter_NESTEROV SolverParameter_SolverType = 1
	SolverParameter_ADAGRAD  SolverParameter_SolverType = 2
)

var SolverParameter_SolverType_name = map[int32]string{
	0: "SGD",
	1: "NESTEROV",
	2: "ADAGRAD",
}
var SolverParameter_SolverType_value = map[string]int32{
	"SGD":      0,
	"NESTEROV": 1,
	"ADAGRAD":  2,
}

func (x SolverParameter_SolverType) Enum() *SolverParameter_SolverType {
	p := new(SolverParameter_SolverType)
	*p = x
	return p
}
func (x SolverParameter_SolverType) String() string {
	return proto.EnumName(SolverParameter_SolverType_name, int32(x))
}
func (x *SolverParameter_SolverType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SolverParameter_SolverType_value, data, "SolverParameter_SolverType")
	if err != nil {
		return err
	}
	*x = SolverParameter_SolverType(value)
	return nil
}
func (SolverParameter_SolverType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1}
}

type ParamSpec_DimCheckMode int32

const (
	// STRICT (default) requires that num, channels, height, width each match.
	ParamSpec_STRICT ParamSpec_DimCheckMode = 0
	// PERMISSIVE requires only the count (num*channels*height*width) to match.
	ParamSpec_PERMISSIVE ParamSpec_DimCheckMode = 1
)

var ParamSpec_DimCheckMode_name = map[int32]string{
	0: "STRICT",
	1: "PERMISSIVE",
}
var ParamSpec_DimCheckMode_value = map[string]int32{
	"STRICT":     0,
	"PERMISSIVE": 1,
}

func (x ParamSpec_DimCheckMode) Enum() *ParamSpec_DimCheckMode {
	p := new(ParamSpec_DimCheckMode)
	*p = x
	return p
}
func (x ParamSpec_DimCheckMode) String() string {
	return proto.EnumName(ParamSpec_DimCheckMode_name, int32(x))
}
func (x *ParamSpec_DimCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParamSpec_DimCheckMode_value, data, "ParamSpec_DimCheckMode")
	if err != nil {
		return err
	}
	*x = ParamSpec_DimCheckMode(value)
	return nil
}
func (ParamSpec_DimCheckMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

type ConvolutionParameter_Engine int32

const (
	ConvolutionParameter_DEFAULT ConvolutionParameter_Engine = 0
	ConvolutionParameter_CAFFE   ConvolutionParameter_Engine = 1
	ConvolutionParameter_CUDNN   ConvolutionParameter_Engine = 2
)

var ConvolutionParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var ConvolutionParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x ConvolutionParameter_Engine) Enum() *ConvolutionParameter_Engine {
	p := new(ConvolutionParameter_Engine)
	*p = x
	return p
}
func (x ConvolutionParameter_Engine) String() string {
	return proto.EnumName(ConvolutionParameter_Engine_name, int32(x))
}
func (x *ConvolutionParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConvolutionParameter_Engine_value, data, "ConvolutionParameter_Engine")
	if err != nil {
		return err
	}
	*x = ConvolutionParameter_Engine(value)
	return nil
}
func (ConvolutionParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{18, 0}
}

type DataParameter_DB int32

const (
	DataParameter_LEVELDB DataParameter_DB = 0
	DataParameter_LMDB    DataParameter_DB = 1
)

var DataParameter_DB_name = map[int32]string{
	0: "LEVELDB",
	1: "LMDB",
}
var DataParameter_DB_value = map[string]int32{
	"LEVELDB": 0,
	"LMDB":    1,
}

func (x DataParameter_DB) Enum() *DataParameter_DB {
	p := new(DataParameter_DB)
	*p = x
	return p
}
func (x DataParameter_DB) String() string {
	return proto.EnumName(DataParameter_DB_name, int32(x))
}
func (x *DataParameter_DB) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DataParameter_DB_value, data, "DataParameter_DB")
	if err != nil {
		return err
	}
	*x = DataParameter_DB(value)
	return nil
}
func (DataParameter_DB) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{19, 0} }

type EltwiseParameter_EltwiseOp int32

const (
	EltwiseParameter_PROD EltwiseParameter_EltwiseOp = 0
	EltwiseParameter_SUM  EltwiseParameter_EltwiseOp = 1
	EltwiseParameter_MAX  EltwiseParameter_EltwiseOp = 2
)

var EltwiseParameter_EltwiseOp_name = map[int32]string{
	0: "PROD",
	1: "SUM",
	2: "MAX",
}
var EltwiseParameter_EltwiseOp_value = map[string]int32{
	"PROD": 0,
	"SUM":  1,
	"MAX":  2,
}

func (x EltwiseParameter_EltwiseOp) Enum() *EltwiseParameter_EltwiseOp {
	p := new(EltwiseParameter_EltwiseOp)
	*p = x
	return p
}
func (x EltwiseParameter_EltwiseOp) String() string {
	return proto.EnumName(EltwiseParameter_EltwiseOp_name, int32(x))
}
func (x *EltwiseParameter_EltwiseOp) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EltwiseParameter_EltwiseOp_value, data, "EltwiseParameter_EltwiseOp")
	if err != nil {
		return err
	}
	*x = EltwiseParameter_EltwiseOp(value)
	return nil
}
func (EltwiseParameter_EltwiseOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{22, 0}
}

type HingeLossParameter_Norm int32

const (
	HingeLossParameter_L1 HingeLossParameter_Norm = 1
	HingeLossParameter_L2 HingeLossParameter_Norm = 2
)

var HingeLossParameter_Norm_name = map[int32]string{
	1: "L1",
	2: "L2",
}
var HingeLossParameter_Norm_value = map[string]int32{
	"L1": 1,
	"L2": 2,
}

func (x HingeLossParameter_Norm) Enum() *HingeLossParameter_Norm {
	p := new(HingeLossParameter_Norm)
	*p = x
	return p
}
func (x HingeLossParameter_Norm) String() string {
	return proto.EnumName(HingeLossParameter_Norm_name, int32(x))
}
func (x *HingeLossParameter_Norm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HingeLossParameter_Norm_value, data, "HingeLossParameter_Norm")
	if err != nil {
		return err
	}
	*x = HingeLossParameter_Norm(value)
	return nil
}
func (HingeLossParameter_Norm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{26, 0} }

type LRNParameter_NormRegion int32

const (
	LRNParameter_ACROSS_CHANNELS LRNParameter_NormRegion = 0
	LRNParameter_WITHIN_CHANNEL  LRNParameter_NormRegion = 1
)

var LRNParameter_NormRegion_name = map[int32]string{
	0: "ACROSS_CHANNELS",
	1: "WITHIN_CHANNEL",
}
var LRNParameter_NormRegion_value = map[string]int32{
	"ACROSS_CHANNELS": 0,
	"WITHIN_CHANNEL":  1,
}

func (x LRNParameter_NormRegion) Enum() *LRNParameter_NormRegion {
	p := new(LRNParameter_NormRegion)
	*p = x
	return p
}
func (x LRNParameter_NormRegion) String() string {
	return proto.EnumName(LRNParameter_NormRegion_name, int32(x))
}
func (x *LRNParameter_NormRegion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LRNParameter_NormRegion_value, data, "LRNParameter_NormRegion")
	if err != nil {
		return err
	}
	*x = LRNParameter_NormRegion(value)
	return nil
}
func (LRNParameter_NormRegion) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{30, 0} }

type PoolingParameter_PoolMethod int32

const (
	PoolingParameter_MAX        PoolingParameter_PoolMethod = 0
	PoolingParameter_AVE        PoolingParameter_PoolMethod = 1
	PoolingParameter_STOCHASTIC PoolingParameter_PoolMethod = 2
)

var PoolingParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var PoolingParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x PoolingParameter_PoolMethod) Enum() *PoolingParameter_PoolMethod {
	p := new(PoolingParameter_PoolMethod)
	*p = x
	return p
}
func (x PoolingParameter_PoolMethod) String() string {
	return proto.EnumName(PoolingParameter_PoolMethod_name, int32(x))
}
func (x *PoolingParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PoolingParameter_PoolMethod_value, data, "PoolingParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = PoolingParameter_PoolMethod(value)
	return nil
}
func (PoolingParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{33, 0}
}

type PoolingParameter_Engine int32

const (
	PoolingParameter_DEFAULT PoolingParameter_Engine = 0
	PoolingParameter_CAFFE   PoolingParameter_Engine = 1
	PoolingParameter_CUDNN   PoolingParameter_Engine = 2
)

var PoolingParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var PoolingParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x PoolingParameter_Engine) Enum() *PoolingParameter_Engine {
	p := new(PoolingParameter_Engine)
	*p = x
	return p
}
func (x PoolingParameter_Engine) String() string {
	return proto.EnumName(PoolingParameter_Engine_name, int32(x))
}
func (x *PoolingParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PoolingParameter_Engine_value, data, "PoolingParameter_Engine")
	if err != nil {
		return err
	}
	*x = PoolingParameter_Engine(value)
	return nil
}
func (PoolingParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 1} }

type ReLUParameter_Engine int32

const (
	ReLUParameter_DEFAULT ReLUParameter_Engine = 0
	ReLUParameter_CAFFE   ReLUParameter_Engine = 1
	ReLUParameter_CUDNN   ReLUParameter_Engine = 2
)

var ReLUParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var ReLUParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x ReLUParameter_Engine) Enum() *ReLUParameter_Engine {
	p := new(ReLUParameter_Engine)
	*p = x
	return p
}
func (x ReLUParameter_Engine) String() string {
	return proto.EnumName(ReLUParameter_Engine_name, int32(x))
}
func (x *ReLUParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReLUParameter_Engine_value, data, "ReLUParameter_Engine")
	if err != nil {
		return err
	}
	*x = ReLUParameter_Engine(value)
	return nil
}
func (ReLUParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{36, 0} }

type SigmoidParameter_Engine int32

const (
	SigmoidParameter_DEFAULT SigmoidParameter_Engine = 0
	SigmoidParameter_CAFFE   SigmoidParameter_Engine = 1
	SigmoidParameter_CUDNN   SigmoidParameter_Engine = 2
)

var SigmoidParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SigmoidParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SigmoidParameter_Engine) Enum() *SigmoidParameter_Engine {
	p := new(SigmoidParameter_Engine)
	*p = x
	return p
}
func (x SigmoidParameter_Engine) String() string {
	return proto.EnumName(SigmoidParameter_Engine_name, int32(x))
}
func (x *SigmoidParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SigmoidParameter_Engine_value, data, "SigmoidParameter_Engine")
	if err != nil {
		return err
	}
	*x = SigmoidParameter_Engine(value)
	return nil
}
func (SigmoidParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{37, 0} }

type SoftmaxParameter_Engine int32

const (
	SoftmaxParameter_DEFAULT SoftmaxParameter_Engine = 0
	SoftmaxParameter_CAFFE   SoftmaxParameter_Engine = 1
	SoftmaxParameter_CUDNN   SoftmaxParameter_Engine = 2
)

var SoftmaxParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SoftmaxParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SoftmaxParameter_Engine) Enum() *SoftmaxParameter_Engine {
	p := new(SoftmaxParameter_Engine)
	*p = x
	return p
}
func (x SoftmaxParameter_Engine) String() string {
	return proto.EnumName(SoftmaxParameter_Engine_name, int32(x))
}
func (x *SoftmaxParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SoftmaxParameter_Engine_value, data, "SoftmaxParameter_Engine")
	if err != nil {
		return err
	}
	*x = SoftmaxParameter_Engine(value)
	return nil
}
func (SoftmaxParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{39, 0} }

type TanHParameter_Engine int32

const (
	TanHParameter_DEFAULT TanHParameter_Engine = 0
	TanHParameter_CAFFE   TanHParameter_Engine = 1
	TanHParameter_CUDNN   TanHParameter_Engine = 2
)

var TanHParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var TanHParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x TanHParameter_Engine) Enum() *TanHParameter_Engine {
	p := new(TanHParameter_Engine)
	*p = x
	return p
}
func (x TanHParameter_Engine) String() string {
	return proto.EnumName(TanHParameter_Engine_name, int32(x))
}
func (x *TanHParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TanHParameter_Engine_value, data, "TanHParameter_Engine")
	if err != nil {
		return err
	}
	*x = TanHParameter_Engine(value)
	return nil
}
func (TanHParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{40, 0} }

type V1LayerParameter_LayerType int32

const (
	V1LayerParameter_NONE                       V1LayerParameter_LayerType = 0
	V1LayerParameter_ABSVAL                     V1LayerParameter_LayerType = 35
	V1LayerParameter_ACCURACY                   V1LayerParameter_LayerType = 1
	V1LayerParameter_ARGMAX                     V1LayerParameter_LayerType = 30
	V1LayerParameter_BNLL                       V1LayerParameter_LayerType = 2
	V1LayerParameter_CONCAT                     V1LayerParameter_LayerType = 3
	V1LayerParameter_CONTRASTIVE_LOSS           V1LayerParameter_LayerType = 37
	V1LayerParameter_CONVOLUTION                V1LayerParameter_LayerType = 4
	V1LayerParameter_DATA                       V1LayerParameter_LayerType = 5
	V1LayerParameter_DECONVOLUTION              V1LayerParameter_LayerType = 39
	V1LayerParameter_DROPOUT                    V1LayerParameter_LayerType = 6
	V1LayerParameter_DUMMY_DATA                 V1LayerParameter_LayerType = 32
	V1LayerParameter_EUCLIDEAN_LOSS             V1LayerParameter_LayerType = 7
	V1LayerParameter_ELTWISE                    V1LayerParameter_LayerType = 25
	V1LayerParameter_EXP                        V1LayerParameter_LayerType = 38
	V1LayerParameter_FLATTEN                    V1LayerParameter_LayerType = 8
	V1LayerParameter_HDF5_DATA                  V1LayerParameter_LayerType = 9
	V1LayerParameter_HDF5_OUTPUT                V1LayerParameter_LayerType = 10
	V1LayerParameter_HINGE_LOSS                 V1LayerParameter_LayerType = 28
	V1LayerParameter_IM2COL                     V1LayerParameter_LayerType = 11
	V1LayerParameter_IMAGE_DATA                 V1LayerParameter_LayerType = 12
	V1LayerParameter_INFOGAIN_LOSS              V1LayerParameter_LayerType = 13
	V1LayerParameter_INNER_PRODUCT              V1LayerParameter_LayerType = 14
	V1LayerParameter_LRN                        V1LayerParameter_LayerType = 15
	V1LayerParameter_MEMORY_DATA                V1LayerParameter_LayerType = 29
	V1LayerParameter_MULTINOMIAL_LOGISTIC_LOSS  V1LayerParameter_LayerType = 16
	V1LayerParameter_MVN                        V1LayerParameter_LayerType = 34
	V1LayerParameter_POOLING                    V1LayerParameter_LayerType = 17
	V1LayerParameter_POWER                      V1LayerParameter_LayerType = 26
	V1LayerParameter_RELU                       V1LayerParameter_LayerType = 18
	V1LayerParameter_SIGMOID                    V1LayerParameter_LayerType = 19
	V1LayerParameter_SIGMOID_CROSS_ENTROPY_LOSS V1LayerParameter_LayerType = 27
	V1LayerParameter_SILENCE                    V1LayerParameter_LayerType = 36
	V1LayerParameter_SOFTMAX                    V1LayerParameter_LayerType = 20
	V1LayerParameter_SOFTMAX_LOSS               V1LayerParameter_LayerType = 21
	V1LayerParameter_SPLIT                      V1LayerParameter_LayerType = 22
	V1LayerParameter_SLICE                      V1LayerParameter_LayerType = 33
	V1LayerParameter_TANH                       V1LayerParameter_LayerType = 23
	V1LayerParameter_WINDOW_DATA                V1LayerParameter_LayerType = 24
	V1LayerParameter_THRESHOLD                  V1LayerParameter_LayerType = 31
)

var V1LayerParameter_LayerType_name = map[int32]string{
	0:  "NONE",
	35: "ABSVAL",
	1:  "ACCURACY",
	30: "ARGMAX",
	2:  "BNLL",
	3:  "CONCAT",
	37: "CONTRASTIVE_LOSS",
	4:  "CONVOLUTION",
	5:  "DATA",
	39: "DECONVOLUTION",
	6:  "DROPOUT",
	32: "DUMMY_DATA",
	7:  "EUCLIDEAN_LOSS",
	25: "ELTWISE",
	38: "EXP",
	8:  "FLATTEN",
	9:  "HDF5_DATA",
	10: "HDF5_OUTPUT",
	28: "HINGE_LOSS",
	11: "IM2COL",
	12: "IMAGE_DATA",
	13: "INFOGAIN_LOSS",
	14: "INNER_PRODUCT",
	15: "LRN",
	29: "MEMORY_DATA",
	16: "MULTINOMIAL_LOGISTIC_LOSS",
	34: "MVN",
	17: "POOLING",
	26: "POWER",
	18: "RELU",
	19: "SIGMOID",
	27: "SIGMOID_CROSS_ENTROPY_LOSS",
	36: "SILENCE",
	20: "SOFTMAX",
	21: "SOFTMAX_LOSS",
	22: "SPLIT",
	33: "SLICE",
	23: "TANH",
	24: "WINDOW_DATA",
	31: "THRESHOLD",
}
var V1LayerParameter_LayerType_value = map[string]int32{
	"NONE":                      0,
	"ABSVAL":                    35,
	"ACCURACY":                  1,
	"ARGMAX":                    30,
	"BNLL":                      2,
	"CONCAT":                    3,
	"CONTRASTIVE_LOSS":          37,
	"CONVOLUTION":               4,
	"DATA":                      5,
	"DECONVOLUTION":             39,
	"DROPOUT":                   6,
	"DUMMY_DATA":                32,
	"EUCLIDEAN_LOSS":            7,
	"ELTWISE":                   25,
	"EXP":                       38,
	"FLATTEN":                   8,
	"HDF5_DATA":                 9,
	"HDF5_OUTPUT":               10,
	"HINGE_LOSS":                28,
	"IM2COL":                    11,
	"IMAGE_DATA":                12,
	"INFOGAIN_LOSS":             13,
	"INNER_PRODUCT":             14,
	"LRN":                       15,
	"MEMORY_DATA":               29,
	"MULTINOMIAL_LOGISTIC_LOSS": 16,
	"MVN":                        34,
	"POOLING":                    17,
	"POWER":                      26,
	"RELU":                       18,
	"SIGMOID":                    19,
	"SIGMOID_CROSS_ENTROPY_LOSS": 27,
	"SILENCE":                    36,
	"SOFTMAX":                    20,
	"SOFTMAX_LOSS":               21,
	"SPLIT":                      22,
	"SLICE":                      33,
	"TANH":                       23,
	"WINDOW_DATA":                24,
	"THRESHOLD":                  31,
}

func (x V1LayerParameter_LayerType) Enum() *V1LayerParameter_LayerType {
	p := new(V1LayerParameter_LayerType)
	*p = x
	return p
}
func (x V1LayerParameter_LayerType) String() string {
	return proto.EnumName(V1LayerParameter_LayerType_name, int32(x))
}
func (x *V1LayerParameter_LayerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(V1LayerParameter_LayerType_value, data, "V1LayerParameter_LayerType")
	if err != nil {
		return err
	}
	*x = V1LayerParameter_LayerType(value)
	return nil
}
func (V1LayerParameter_LayerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{43, 0}
}

type V1LayerParameter_DimCheckMode int32

const (
	V1LayerParameter_STRICT     V1LayerParameter_DimCheckMode = 0
	V1LayerParameter_PERMISSIVE V1LayerParameter_DimCheckMode = 1
)

var V1LayerParameter_DimCheckMode_name = map[int32]string{
	0: "STRICT",
	1: "PERMISSIVE",
}
var V1LayerParameter_DimCheckMode_value = map[string]int32{
	"STRICT":     0,
	"PERMISSIVE": 1,
}

func (x V1LayerParameter_DimCheckMode) Enum() *V1LayerParameter_DimCheckMode {
	p := new(V1LayerParameter_DimCheckMode)
	*p = x
	return p
}
func (x V1LayerParameter_DimCheckMode) String() string {
	return proto.EnumName(V1LayerParameter_DimCheckMode_name, int32(x))
}
func (x *V1LayerParameter_DimCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(V1LayerParameter_DimCheckMode_value, data, "V1LayerParameter_DimCheckMode")
	if err != nil {
		return err
	}
	*x = V1LayerParameter_DimCheckMode(value)
	return nil
}
func (V1LayerParameter_DimCheckMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{43, 1}
}

type V0LayerParameter_PoolMethod int32

const (
	V0LayerParameter_MAX        V0LayerParameter_PoolMethod = 0
	V0LayerParameter_AVE        V0LayerParameter_PoolMethod = 1
	V0LayerParameter_STOCHASTIC V0LayerParameter_PoolMethod = 2
)

var V0LayerParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var V0LayerParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x V0LayerParameter_PoolMethod) Enum() *V0LayerParameter_PoolMethod {
	p := new(V0LayerParameter_PoolMethod)
	*p = x
	return p
}
func (x V0LayerParameter_PoolMethod) String() string {
	return proto.EnumName(V0LayerParameter_PoolMethod_name, int32(x))
}
func (x *V0LayerParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(V0LayerParameter_PoolMethod_value, data, "V0LayerParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = V0LayerParameter_PoolMethod(value)
	return nil
}
func (V0LayerParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{44, 0}
}

// Specifies the shape (dimensions) of a Blob.
type BlobShape struct {
	Dim              []int64 `protobuf:"varint,1,rep,packed,name=dim" json:"dim,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlobShape) Reset()                    { *m = BlobShape{} }
func (m *BlobShape) String() string            { return proto.CompactTextString(m) }
func (*BlobShape) ProtoMessage()               {}
func (*BlobShape) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BlobShape) GetDim() []int64 {
	if m != nil {
		return m.Dim
	}
	return nil
}

type BlobProto struct {
	Shape *BlobShape `protobuf:"bytes,7,opt,name=shape" json:"shape,omitempty"`
	Data  []float32  `protobuf:"fixed32,5,rep,packed,name=data" json:"data,omitempty"`
	Diff  []float32  `protobuf:"fixed32,6,rep,packed,name=diff" json:"diff,omitempty"`
	// 4D dimensions -- deprecated.  Use "shape" instead.
	Num              *int32 `protobuf:"varint,1,opt,name=num,def=0" json:"num,omitempty"`
	Channels         *int32 `protobuf:"varint,2,opt,name=channels,def=0" json:"channels,omitempty"`
	Height           *int32 `protobuf:"varint,3,opt,name=height,def=0" json:"height,omitempty"`
	Width            *int32 `protobuf:"varint,4,opt,name=width,def=0" json:"width,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BlobProto) Reset()                    { *m = BlobProto{} }
func (m *BlobProto) String() string            { return proto.CompactTextString(m) }
func (*BlobProto) ProtoMessage()               {}
func (*BlobProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

const Default_BlobProto_Num int32 = 0
const Default_BlobProto_Channels int32 = 0
const Default_BlobProto_Height int32 = 0
const Default_BlobProto_Width int32 = 0

func (m *BlobProto) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *BlobProto) GetData() []float32 {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *BlobProto) GetDiff() []float32 {
	if m != nil {
		return m.Diff
	}
	return nil
}

func (m *BlobProto) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return Default_BlobProto_Num
}

func (m *BlobProto) GetChannels() int32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return Default_BlobProto_Channels
}

func (m *BlobProto) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return Default_BlobProto_Height
}

func (m *BlobProto) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return Default_BlobProto_Width
}

// The BlobProtoVector is simply a way to pass multiple blobproto instances
// around.
type BlobProtoVector struct {
	Blobs            []*BlobProto `protobuf:"bytes,1,rep,name=blobs" json:"blobs,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *BlobProtoVector) Reset()                    { *m = BlobProtoVector{} }
func (m *BlobProtoVector) String() string            { return proto.CompactTextString(m) }
func (*BlobProtoVector) ProtoMessage()               {}
func (*BlobProtoVector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *BlobProtoVector) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

type Datum struct {
	Channels *int32 `protobuf:"varint,1,opt,name=channels" json:"channels,omitempty"`
	Height   *int32 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
	Width    *int32 `protobuf:"varint,3,opt,name=width" json:"width,omitempty"`
	// the actual image data, in bytes
	Data  []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	Label *int32 `protobuf:"varint,5,opt,name=label" json:"label,omitempty"`
	// Optionally, the datum could also hold float data.
	FloatData []float32 `protobuf:"fixed32,6,rep,name=float_data" json:"float_data,omitempty"`
	// If true data contains an encoded image that need to be decoded
	Encoded          *bool  `protobuf:"varint,7,opt,name=encoded,def=0" json:"encoded,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Datum) Reset()                    { *m = Datum{} }
func (m *Datum) String() string            { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()               {}
func (*Datum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

const Default_Datum_Encoded bool = false

func (m *Datum) GetChannels() int32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return 0
}

func (m *Datum) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *Datum) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

func (m *Datum) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Datum) GetLabel() int32 {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return 0
}

func (m *Datum) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *Datum) GetEncoded() bool {
	if m != nil && m.Encoded != nil {
		return *m.Encoded
	}
	return Default_Datum_Encoded
}

type FillerParameter struct {
	// The filler type.
	Type  *string  `protobuf:"bytes,1,opt,name=type,def=constant" json:"type,omitempty"`
	Value *float32 `protobuf:"fixed32,2,opt,name=value,def=0" json:"value,omitempty"`
	Min   *float32 `protobuf:"fixed32,3,opt,name=min,def=0" json:"min,omitempty"`
	Max   *float32 `protobuf:"fixed32,4,opt,name=max,def=1" json:"max,omitempty"`
	Mean  *float32 `protobuf:"fixed32,5,opt,name=mean,def=0" json:"mean,omitempty"`
	Std   *float32 `protobuf:"fixed32,6,opt,name=std,def=1" json:"std,omitempty"`
	// The expected number of non-zero output weights for a given input in
	// Gaussian filler -- the default -1 means don't perform sparsification.
	Sparse           *int32 `protobuf:"varint,7,opt,name=sparse,def=-1" json:"sparse,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FillerParameter) Reset()                    { *m = FillerParameter{} }
func (m *FillerParameter) String() string            { return proto.CompactTextString(m) }
func (*FillerParameter) ProtoMessage()               {}
func (*FillerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_FillerParameter_Type string = "constant"
const Default_FillerParameter_Value float32 = 0
const Default_FillerParameter_Min float32 = 0
const Default_FillerParameter_Max float32 = 1
const Default_FillerParameter_Mean float32 = 0
const Default_FillerParameter_Std float32 = 1
const Default_FillerParameter_Sparse int32 = -1

func (m *FillerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_FillerParameter_Type
}

func (m *FillerParameter) GetValue() float32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return Default_FillerParameter_Value
}

func (m *FillerParameter) GetMin() float32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return Default_FillerParameter_Min
}

func (m *FillerParameter) GetMax() float32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return Default_FillerParameter_Max
}

func (m *FillerParameter) GetMean() float32 {
	if m != nil && m.Mean != nil {
		return *m.Mean
	}
	return Default_FillerParameter_Mean
}

func (m *FillerParameter) GetStd() float32 {
	if m != nil && m.Std != nil {
		return *m.Std
	}
	return Default_FillerParameter_Std
}

func (m *FillerParameter) GetSparse() int32 {
	if m != nil && m.Sparse != nil {
		return *m.Sparse
	}
	return Default_FillerParameter_Sparse
}

type NetParameter struct {
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The input blobs to the network.
	Input []string `protobuf:"bytes,3,rep,name=input" json:"input,omitempty"`
	// The shape of the input blobs.
	InputShape []*BlobShape `protobuf:"bytes,8,rep,name=input_shape" json:"input_shape,omitempty"`
	// 4D input dimensions -- deprecated.  Use "shape" instead.
	// If specified, for each input blob there should be four
	// values specifying the num, channels, height and width of the input blob.
	// Thus, there should be a total of (4 * #input) numbers.
	InputDim []int32 `protobuf:"varint,4,rep,name=input_dim" json:"input_dim,omitempty"`
	// Whether the network will force every layer to carry out backward operation.
	// If set False, then whether to carry out backward is determined
	// automatically according to the net structure and learning rates.
	ForceBackward *bool `protobuf:"varint,5,opt,name=force_backward,def=0" json:"force_backward,omitempty"`
	// The current "state" of the network, including the phase, level, and stage.
	// Some layers may be included/excluded depending on this state and the states
	// specified in the layers' include and exclude fields.
	State *NetState `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	// Print debugging information about results while running Net::Forward,
	// Net::Backward, and Net::Update.
	DebugInfo *bool `protobuf:"varint,7,opt,name=debug_info,def=0" json:"debug_info,omitempty"`
	// The layers that make up the net.  Each of their configurations, including
	// connectivity and behavior, is specified as a LayerParameter.
	Layer []*LayerParameter `protobuf:"bytes,100,rep,name=layer" json:"layer,omitempty"`
	// DEPRECATED: use 'layer' instead.
	Layers           []*V1LayerParameter `protobuf:"bytes,2,rep,name=layers" json:"layers,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *NetParameter) Reset()                    { *m = NetParameter{} }
func (m *NetParameter) String() string            { return proto.CompactTextString(m) }
func (*NetParameter) ProtoMessage()               {}
func (*NetParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

const Default_NetParameter_ForceBackward bool = false
const Default_NetParameter_DebugInfo bool = false

func (m *NetParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetParameter) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NetParameter) GetInputShape() []*BlobShape {
	if m != nil {
		return m.InputShape
	}
	return nil
}

func (m *NetParameter) GetInputDim() []int32 {
	if m != nil {
		return m.InputDim
	}
	return nil
}

func (m *NetParameter) GetForceBackward() bool {
	if m != nil && m.ForceBackward != nil {
		return *m.ForceBackward
	}
	return Default_NetParameter_ForceBackward
}

func (m *NetParameter) GetState() *NetState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NetParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_NetParameter_DebugInfo
}

func (m *NetParameter) GetLayer() []*LayerParameter {
	if m != nil {
		return m.Layer
	}
	return nil
}

func (m *NetParameter) GetLayers() []*V1LayerParameter {
	if m != nil {
		return m.Layers
	}
	return nil
}

// NOTE
// Update the next available ID when you add a new SolverParameter field.
//
// SolverParameter next available ID: 36 (last added: clip_gradients)
type SolverParameter struct {
	// Proto filename for the train net, possibly combined with one or more
	// test nets.
	Net *string `protobuf:"bytes,24,opt,name=net" json:"net,omitempty"`
	// Inline train net param, possibly combined with one or more test nets.
	NetParam      *NetParameter   `protobuf:"bytes,25,opt,name=net_param" json:"net_param,omitempty"`
	TrainNet      *string         `protobuf:"bytes,1,opt,name=train_net" json:"train_net,omitempty"`
	TestNet       []string        `protobuf:"bytes,2,rep,name=test_net" json:"test_net,omitempty"`
	TrainNetParam *NetParameter   `protobuf:"bytes,21,opt,name=train_net_param" json:"train_net_param,omitempty"`
	TestNetParam  []*NetParameter `protobuf:"bytes,22,rep,name=test_net_param" json:"test_net_param,omitempty"`
	// The states for the train/test nets. Must be unspecified or
	// specified once per net.
	//
	// By default, all states will have solver = true;
	// train_state will have phase = TRAIN,
	// and all test_state's will have phase = TEST.
	// Other defaults are set according to the NetState defaults.
	TrainState *NetState   `protobuf:"bytes,26,opt,name=train_state" json:"train_state,omitempty"`
	TestState  []*NetState `protobuf:"bytes,27,rep,name=test_state" json:"test_state,omitempty"`
	// The number of iterations for each test net.
	TestIter []int32 `protobuf:"varint,3,rep,name=test_iter" json:"test_iter,omitempty"`
	// The number of iterations between two testing phases.
	TestInterval    *int32 `protobuf:"varint,4,opt,name=test_interval,def=0" json:"test_interval,omitempty"`
	TestComputeLoss *bool  `protobuf:"varint,19,opt,name=test_compute_loss,def=0" json:"test_compute_loss,omitempty"`
	// If true, run an initial test pass before the first iteration,
	// ensuring memory availability and printing the starting value of the loss.
	TestInitialization *bool    `protobuf:"varint,32,opt,name=test_initialization,def=1" json:"test_initialization,omitempty"`
	BaseLr             *float32 `protobuf:"fixed32,5,opt,name=base_lr" json:"base_lr,omitempty"`
	// the number of iterations between displaying info. If display = 0, no info
	// will be displayed.
	Display *int32 `protobuf:"varint,6,opt,name=display" json:"display,omitempty"`
	// Display the loss averaged over the last average_loss iterations
	AverageLoss *int32   `protobuf:"varint,33,opt,name=average_loss,def=1" json:"average_loss,omitempty"`
	MaxIter     *int32   `protobuf:"varint,7,opt,name=max_iter" json:"max_iter,omitempty"`
	LrPolicy    *string  `protobuf:"bytes,8,opt,name=lr_policy" json:"lr_policy,omitempty"`
	Gamma       *float32 `protobuf:"fixed32,9,opt,name=gamma" json:"gamma,omitempty"`
	Power       *float32 `protobuf:"fixed32,10,opt,name=power" json:"power,omitempty"`
	Momentum    *float32 `protobuf:"fixed32,11,opt,name=momentum" json:"momentum,omitempty"`
	WeightDecay *float32 `protobuf:"fixed32,12,opt,name=weight_decay" json:"weight_decay,omitempty"`
	// regularization types supported: L1 and L2
	// controlled by weight_decay
	RegularizationType *string `protobuf:"bytes,29,opt,name=regularization_type,def=L2" json:"regularization_type,omitempty"`
	// the stepsize for learning rate policy "step"
	Stepsize *int32 `protobuf:"varint,13,opt,name=stepsize" json:"stepsize,omitempty"`
	// the stepsize for learning rate policy "multistep"
	Stepvalue []int32 `protobuf:"varint,34,rep,name=stepvalue" json:"stepvalue,omitempty"`
	// Set clip_gradients to >= 0 to clip parameter gradients to that L2 norm,
	// whenever their actual L2 norm is larger.
	ClipGradients  *float32 `protobuf:"fixed32,35,opt,name=clip_gradients,def=-1" json:"clip_gradients,omitempty"`
	Snapshot       *int32   `protobuf:"varint,14,opt,name=snapshot,def=0" json:"snapshot,omitempty"`
	SnapshotPrefix *string  `protobuf:"bytes,15,opt,name=snapshot_prefix" json:"snapshot_prefix,omitempty"`
	// whether to snapshot diff in the results or not. Snapshotting diff will help
	// debugging but the final protocol buffer size will be much larger.
	SnapshotDiff *bool                       `protobuf:"varint,16,opt,name=snapshot_diff,def=0" json:"snapshot_diff,omitempty"`
	SolverMode   *SolverParameter_SolverMode `protobuf:"varint,17,opt,name=solver_mode,enum=caffe.SolverParameter_SolverMode,def=1" json:"solver_mode,omitempty"`
	// the device_id will that be used in GPU mode. Use device_id = 0 in default.
	DeviceId *int32 `protobuf:"varint,18,opt,name=device_id,def=0" json:"device_id,omitempty"`
	// If non-negative, the seed with which the Solver will initialize the Caffe
	// random number generator -- useful for reproducible results. Otherwise,
	// (and by default) initialize using a seed derived from the system clock.
	RandomSeed *int64                      `protobuf:"varint,20,opt,name=random_seed,def=-1" json:"random_seed,omitempty"`
	SolverType *SolverParameter_SolverType `protobuf:"varint,30,opt,name=solver_type,enum=caffe.SolverParameter_SolverType,def=0" json:"solver_type,omitempty"`
	// numerical stability for AdaGrad
	Delta *float32 `protobuf:"fixed32,31,opt,name=delta,def=1e-08" json:"delta,omitempty"`
	// If true, print information about the state of the net that may help with
	// debugging learning problems.
	DebugInfo *bool `protobuf:"varint,23,opt,name=debug_info,def=0" json:"debug_info,omitempty"`
	// If false, don't save a snapshot after training finishes.
	SnapshotAfterTrain *bool  `protobuf:"varint,28,opt,name=snapshot_after_train,def=1" json:"snapshot_after_train,omitempty"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *SolverParameter) Reset()                    { *m = SolverParameter{} }
func (m *SolverParameter) String() string            { return proto.CompactTextString(m) }
func (*SolverParameter) ProtoMessage()               {}
func (*SolverParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

const Default_SolverParameter_TestInterval int32 = 0
const Default_SolverParameter_TestComputeLoss bool = false
const Default_SolverParameter_TestInitialization bool = true
const Default_SolverParameter_AverageLoss int32 = 1
const Default_SolverParameter_RegularizationType string = "L2"
const Default_SolverParameter_ClipGradients float32 = -1
const Default_SolverParameter_Snapshot int32 = 0
const Default_SolverParameter_SnapshotDiff bool = false
const Default_SolverParameter_SolverMode SolverParameter_SolverMode = SolverParameter_GPU
const Default_SolverParameter_DeviceId int32 = 0
const Default_SolverParameter_RandomSeed int64 = -1
const Default_SolverParameter_SolverType SolverParameter_SolverType = SolverParameter_SGD
const Default_SolverParameter_Delta float32 = 1e-08
const Default_SolverParameter_DebugInfo bool = false
const Default_SolverParameter_SnapshotAfterTrain bool = true

func (m *SolverParameter) GetNet() string {
	if m != nil && m.Net != nil {
		return *m.Net
	}
	return ""
}

func (m *SolverParameter) GetNetParam() *NetParameter {
	if m != nil {
		return m.NetParam
	}
	return nil
}

func (m *SolverParameter) GetTrainNet() string {
	if m != nil && m.TrainNet != nil {
		return *m.TrainNet
	}
	return ""
}

func (m *SolverParameter) GetTestNet() []string {
	if m != nil {
		return m.TestNet
	}
	return nil
}

func (m *SolverParameter) GetTrainNetParam() *NetParameter {
	if m != nil {
		return m.TrainNetParam
	}
	return nil
}

func (m *SolverParameter) GetTestNetParam() []*NetParameter {
	if m != nil {
		return m.TestNetParam
	}
	return nil
}

func (m *SolverParameter) GetTrainState() *NetState {
	if m != nil {
		return m.TrainState
	}
	return nil
}

func (m *SolverParameter) GetTestState() []*NetState {
	if m != nil {
		return m.TestState
	}
	return nil
}

func (m *SolverParameter) GetTestIter() []int32 {
	if m != nil {
		return m.TestIter
	}
	return nil
}

func (m *SolverParameter) GetTestInterval() int32 {
	if m != nil && m.TestInterval != nil {
		return *m.TestInterval
	}
	return Default_SolverParameter_TestInterval
}

func (m *SolverParameter) GetTestComputeLoss() bool {
	if m != nil && m.TestComputeLoss != nil {
		return *m.TestComputeLoss
	}
	return Default_SolverParameter_TestComputeLoss
}

func (m *SolverParameter) GetTestInitialization() bool {
	if m != nil && m.TestInitialization != nil {
		return *m.TestInitialization
	}
	return Default_SolverParameter_TestInitialization
}

func (m *SolverParameter) GetBaseLr() float32 {
	if m != nil && m.BaseLr != nil {
		return *m.BaseLr
	}
	return 0
}

func (m *SolverParameter) GetDisplay() int32 {
	if m != nil && m.Display != nil {
		return *m.Display
	}
	return 0
}

func (m *SolverParameter) GetAverageLoss() int32 {
	if m != nil && m.AverageLoss != nil {
		return *m.AverageLoss
	}
	return Default_SolverParameter_AverageLoss
}

func (m *SolverParameter) GetMaxIter() int32 {
	if m != nil && m.MaxIter != nil {
		return *m.MaxIter
	}
	return 0
}

func (m *SolverParameter) GetLrPolicy() string {
	if m != nil && m.LrPolicy != nil {
		return *m.LrPolicy
	}
	return ""
}

func (m *SolverParameter) GetGamma() float32 {
	if m != nil && m.Gamma != nil {
		return *m.Gamma
	}
	return 0
}

func (m *SolverParameter) GetPower() float32 {
	if m != nil && m.Power != nil {
		return *m.Power
	}
	return 0
}

func (m *SolverParameter) GetMomentum() float32 {
	if m != nil && m.Momentum != nil {
		return *m.Momentum
	}
	return 0
}

func (m *SolverParameter) GetWeightDecay() float32 {
	if m != nil && m.WeightDecay != nil {
		return *m.WeightDecay
	}
	return 0
}

func (m *SolverParameter) GetRegularizationType() string {
	if m != nil && m.RegularizationType != nil {
		return *m.RegularizationType
	}
	return Default_SolverParameter_RegularizationType
}

func (m *SolverParameter) GetStepsize() int32 {
	if m != nil && m.Stepsize != nil {
		return *m.Stepsize
	}
	return 0
}

func (m *SolverParameter) GetStepvalue() []int32 {
	if m != nil {
		return m.Stepvalue
	}
	return nil
}

func (m *SolverParameter) GetClipGradients() float32 {
	if m != nil && m.ClipGradients != nil {
		return *m.ClipGradients
	}
	return Default_SolverParameter_ClipGradients
}

func (m *SolverParameter) GetSnapshot() int32 {
	if m != nil && m.Snapshot != nil {
		return *m.Snapshot
	}
	return Default_SolverParameter_Snapshot
}

func (m *SolverParameter) GetSnapshotPrefix() string {
	if m != nil && m.SnapshotPrefix != nil {
		return *m.SnapshotPrefix
	}
	return ""
}

func (m *SolverParameter) GetSnapshotDiff() bool {
	if m != nil && m.SnapshotDiff != nil {
		return *m.SnapshotDiff
	}
	return Default_SolverParameter_SnapshotDiff
}

func (m *SolverParameter) GetSolverMode() SolverParameter_SolverMode {
	if m != nil && m.SolverMode != nil {
		return *m.SolverMode
	}
	return Default_SolverParameter_SolverMode
}

func (m *SolverParameter) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return Default_SolverParameter_DeviceId
}

func (m *SolverParameter) GetRandomSeed() int64 {
	if m != nil && m.RandomSeed != nil {
		return *m.RandomSeed
	}
	return Default_SolverParameter_RandomSeed
}

func (m *SolverParameter) GetSolverType() SolverParameter_SolverType {
	if m != nil && m.SolverType != nil {
		return *m.SolverType
	}
	return Default_SolverParameter_SolverType
}

func (m *SolverParameter) GetDelta() float32 {
	if m != nil && m.Delta != nil {
		return *m.Delta
	}
	return Default_SolverParameter_Delta
}

func (m *SolverParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_SolverParameter_DebugInfo
}

func (m *SolverParameter) GetSnapshotAfterTrain() bool {
	if m != nil && m.SnapshotAfterTrain != nil {
		return *m.SnapshotAfterTrain
	}
	return Default_SolverParameter_SnapshotAfterTrain
}

// A message that stores the solver snapshots
type SolverState struct {
	Iter             *int32       `protobuf:"varint,1,opt,name=iter" json:"iter,omitempty"`
	LearnedNet       *string      `protobuf:"bytes,2,opt,name=learned_net" json:"learned_net,omitempty"`
	History          []*BlobProto `protobuf:"bytes,3,rep,name=history" json:"history,omitempty"`
	CurrentStep      *int32       `protobuf:"varint,4,opt,name=current_step,def=0" json:"current_step,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *SolverState) Reset()                    { *m = SolverState{} }
func (m *SolverState) String() string            { return proto.CompactTextString(m) }
func (*SolverState) ProtoMessage()               {}
func (*SolverState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

const Default_SolverState_CurrentStep int32 = 0

func (m *SolverState) GetIter() int32 {
	if m != nil && m.Iter != nil {
		return *m.Iter
	}
	return 0
}

func (m *SolverState) GetLearnedNet() string {
	if m != nil && m.LearnedNet != nil {
		return *m.LearnedNet
	}
	return ""
}

func (m *SolverState) GetHistory() []*BlobProto {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *SolverState) GetCurrentStep() int32 {
	if m != nil && m.CurrentStep != nil {
		return *m.CurrentStep
	}
	return Default_SolverState_CurrentStep
}

type NetState struct {
	Phase            *Phase   `protobuf:"varint,1,opt,name=phase,enum=caffe.Phase,def=1" json:"phase,omitempty"`
	Level            *int32   `protobuf:"varint,2,opt,name=level,def=0" json:"level,omitempty"`
	Stage            []string `protobuf:"bytes,3,rep,name=stage" json:"stage,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NetState) Reset()                    { *m = NetState{} }
func (m *NetState) String() string            { return proto.CompactTextString(m) }
func (*NetState) ProtoMessage()               {}
func (*NetState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

const Default_NetState_Phase Phase = Phase_TEST
const Default_NetState_Level int32 = 0

func (m *NetState) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Default_NetState_Phase
}

func (m *NetState) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return Default_NetState_Level
}

func (m *NetState) GetStage() []string {
	if m != nil {
		return m.Stage
	}
	return nil
}

type NetStateRule struct {
	// Set phase to require the NetState have a particular phase (TRAIN or TEST)
	// to meet this rule.
	Phase *Phase `protobuf:"varint,1,opt,name=phase,enum=caffe.Phase" json:"phase,omitempty"`
	// Set the minimum and/or maximum levels in which the layer should be used.
	// Leave undefined to meet the rule regardless of level.
	MinLevel *int32 `protobuf:"varint,2,opt,name=min_level" json:"min_level,omitempty"`
	MaxLevel *int32 `protobuf:"varint,3,opt,name=max_level" json:"max_level,omitempty"`
	// Customizable sets of stages to include or exclude.
	// The net must have ALL of the specified stages and NONE of the specified
	// "not_stage"s to meet the rule.
	// (Use multiple NetStateRules to specify conjunctions of stages.)
	Stage            []string `protobuf:"bytes,4,rep,name=stage" json:"stage,omitempty"`
	NotStage         []string `protobuf:"bytes,5,rep,name=not_stage" json:"not_stage,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NetStateRule) Reset()                    { *m = NetStateRule{} }
func (m *NetStateRule) String() string            { return proto.CompactTextString(m) }
func (*NetStateRule) ProtoMessage()               {}
func (*NetStateRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *NetStateRule) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Phase_TRAIN
}

func (m *NetStateRule) GetMinLevel() int32 {
	if m != nil && m.MinLevel != nil {
		return *m.MinLevel
	}
	return 0
}

func (m *NetStateRule) GetMaxLevel() int32 {
	if m != nil && m.MaxLevel != nil {
		return *m.MaxLevel
	}
	return 0
}

func (m *NetStateRule) GetStage() []string {
	if m != nil {
		return m.Stage
	}
	return nil
}

func (m *NetStateRule) GetNotStage() []string {
	if m != nil {
		return m.NotStage
	}
	return nil
}

// Specifies training parameters (multipliers on global learning constants,
// and the name and other settings used for weight sharing).
type ParamSpec struct {
	// The names of the parameter blobs -- useful for sharing parameters among
	// layers, but never required otherwise.  To share a parameter between two
	// layers, give it a (non-empty) name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Whether to require shared weights to have the same shape, or just the same
	// count -- defaults to STRICT if unspecified.
	ShareMode *ParamSpec_DimCheckMode `protobuf:"varint,2,opt,name=share_mode,enum=caffe.ParamSpec_DimCheckMode" json:"share_mode,omitempty"`
	// The multiplier on the global learning rate for this parameter.
	LrMult *float32 `protobuf:"fixed32,3,opt,name=lr_mult,def=1" json:"lr_mult,omitempty"`
	// The multiplier on the global weight decay for this parameter.
	DecayMult        *float32 `protobuf:"fixed32,4,opt,name=decay_mult,def=1" json:"decay_mult,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ParamSpec) Reset()                    { *m = ParamSpec{} }
func (m *ParamSpec) String() string            { return proto.CompactTextString(m) }
func (*ParamSpec) ProtoMessage()               {}
func (*ParamSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

const Default_ParamSpec_LrMult float32 = 1
const Default_ParamSpec_DecayMult float32 = 1

func (m *ParamSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ParamSpec) GetShareMode() ParamSpec_DimCheckMode {
	if m != nil && m.ShareMode != nil {
		return *m.ShareMode
	}
	return ParamSpec_STRICT
}

func (m *ParamSpec) GetLrMult() float32 {
	if m != nil && m.LrMult != nil {
		return *m.LrMult
	}
	return Default_ParamSpec_LrMult
}

func (m *ParamSpec) GetDecayMult() float32 {
	if m != nil && m.DecayMult != nil {
		return *m.DecayMult
	}
	return Default_ParamSpec_DecayMult
}

// NOTE
// Update the next available ID when you add a new LayerParameter field.
//
// LayerParameter next available layer-specific ID: 132 (last added: prelu_param)
type LayerParameter struct {
	Name   *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type   *string  `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Bottom []string `protobuf:"bytes,3,rep,name=bottom" json:"bottom,omitempty"`
	Top    []string `protobuf:"bytes,4,rep,name=top" json:"top,omitempty"`
	// The train / test phase for computation.
	Phase *Phase `protobuf:"varint,10,opt,name=phase,enum=caffe.Phase" json:"phase,omitempty"`
	// The amount of weight to assign each top blob in the objective.
	// Each layer assigns a default value, usually of either 0 or 1,
	// to each top blob.
	LossWeight []float32 `protobuf:"fixed32,5,rep,name=loss_weight" json:"loss_weight,omitempty"`
	// Specifies training parameters (multipliers on global learning constants,
	// and the name and other settings used for weight sharing).
	Param []*ParamSpec `protobuf:"bytes,6,rep,name=param" json:"param,omitempty"`
	// The blobs containing the numeric parameters of the layer.
	Blobs []*BlobProto `protobuf:"bytes,7,rep,name=blobs" json:"blobs,omitempty"`
	// Rules controlling whether and when a layer is included in the network,
	// based on the current NetState.  You may specify a non-zero number of rules
	// to include OR exclude, but not both.  If no include or exclude rules are
	// specified, the layer is always included.  If the current NetState meets
	// ANY (i.e., one or more) of the specified rules, the layer is
	// included/excluded.
	Include []*NetStateRule `protobuf:"bytes,8,rep,name=include" json:"include,omitempty"`
	Exclude []*NetStateRule `protobuf:"bytes,9,rep,name=exclude" json:"exclude,omitempty"`
	// Parameters for data pre-processing.
	TransformParam *TransformationParameter `protobuf:"bytes,100,opt,name=transform_param" json:"transform_param,omitempty"`
	// Parameters shared by loss layers.
	LossParam *LossParameter `protobuf:"bytes,101,opt,name=loss_param" json:"loss_param,omitempty"`
	// Layer type-specific parameters.
	//
	// Note: certain layers may have more than one computational engine
	// for their implementation. These layers include an Engine type and
	// engine parameter for selecting the implementation.
	// The default for the engine is set by the ENGINE switch at compile-time.
	AccuracyParam        *AccuracyParameter        `protobuf:"bytes,102,opt,name=accuracy_param" json:"accuracy_param,omitempty"`
	ArgmaxParam          *ArgMaxParameter          `protobuf:"bytes,103,opt,name=argmax_param" json:"argmax_param,omitempty"`
	ConcatParam          *ConcatParameter          `protobuf:"bytes,104,opt,name=concat_param" json:"concat_param,omitempty"`
	ContrastiveLossParam *ContrastiveLossParameter `protobuf:"bytes,105,opt,name=contrastive_loss_param" json:"contrastive_loss_param,omitempty"`
	ConvolutionParam     *ConvolutionParameter     `protobuf:"bytes,106,opt,name=convolution_param" json:"convolution_param,omitempty"`
	DataParam            *DataParameter            `protobuf:"bytes,107,opt,name=data_param" json:"data_param,omitempty"`
	DropoutParam         *DropoutParameter         `protobuf:"bytes,108,opt,name=dropout_param" json:"dropout_param,omitempty"`
	DummyDataParam       *DummyDataParameter       `protobuf:"bytes,109,opt,name=dummy_data_param" json:"dummy_data_param,omitempty"`
	EltwiseParam         *EltwiseParameter         `protobuf:"bytes,110,opt,name=eltwise_param" json:"eltwise_param,omitempty"`
	ExpParam             *ExpParameter             `protobuf:"bytes,111,opt,name=exp_param" json:"exp_param,omitempty"`
	Hdf5DataParam        *HDF5DataParameter        `protobuf:"bytes,112,opt,name=hdf5_data_param" json:"hdf5_data_param,omitempty"`
	Hdf5OutputParam      *HDF5OutputParameter      `protobuf:"bytes,113,opt,name=hdf5_output_param" json:"hdf5_output_param,omitempty"`
	HingeLossParam       *HingeLossParameter       `protobuf:"bytes,114,opt,name=hinge_loss_param" json:"hinge_loss_param,omitempty"`
	ImageDataParam       *ImageDataParameter       `protobuf:"bytes,115,opt,name=image_data_param" json:"image_data_param,omitempty"`
	InfogainLossParam    *InfogainLossParameter    `protobuf:"bytes,116,opt,name=infogain_loss_param" json:"infogain_loss_param,omitempty"`
	InnerProductParam    *InnerProductParameter    `protobuf:"bytes,117,opt,name=inner_product_param" json:"inner_product_param,omitempty"`
	LrnParam             *LRNParameter             `protobuf:"bytes,118,opt,name=lrn_param" json:"lrn_param,omitempty"`
	MemoryDataParam      *MemoryDataParameter      `protobuf:"bytes,119,opt,name=memory_data_param" json:"memory_data_param,omitempty"`
	MvnParam             *MVNParameter             `protobuf:"bytes,120,opt,name=mvn_param" json:"mvn_param,omitempty"`
	PoolingParam         *PoolingParameter         `protobuf:"bytes,121,opt,name=pooling_param" json:"pooling_param,omitempty"`
	PowerParam           *PowerParameter           `protobuf:"bytes,122,opt,name=power_param" json:"power_param,omitempty"`
	PreluParam           *PReLUParameter           `protobuf:"bytes,131,opt,name=prelu_param" json:"prelu_param,omitempty"`
	PythonParam          *PythonParameter          `protobuf:"bytes,130,opt,name=python_param" json:"python_param,omitempty"`
	ReluParam            *ReLUParameter            `protobuf:"bytes,123,opt,name=relu_param" json:"relu_param,omitempty"`
	SigmoidParam         *SigmoidParameter         `protobuf:"bytes,124,opt,name=sigmoid_param" json:"sigmoid_param,omitempty"`
	SoftmaxParam         *SoftmaxParameter         `protobuf:"bytes,125,opt,name=softmax_param" json:"softmax_param,omitempty"`
	SliceParam           *SliceParameter           `protobuf:"bytes,126,opt,name=slice_param" json:"slice_param,omitempty"`
	TanhParam            *TanHParameter            `protobuf:"bytes,127,opt,name=tanh_param" json:"tanh_param,omitempty"`
	ThresholdParam       *ThresholdParameter       `protobuf:"bytes,128,opt,name=threshold_param" json:"threshold_param,omitempty"`
	WindowDataParam      *WindowDataParameter      `protobuf:"bytes,129,opt,name=window_data_param" json:"window_data_param,omitempty"`
	XXX_unrecognized     []byte                    `json:"-"`
}

func (m *LayerParameter) Reset()                    { *m = LayerParameter{} }
func (m *LayerParameter) String() string            { return proto.CompactTextString(m) }
func (*LayerParameter) ProtoMessage()               {}
func (*LayerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *LayerParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *LayerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *LayerParameter) GetBottom() []string {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *LayerParameter) GetTop() []string {
	if m != nil {
		return m.Top
	}
	return nil
}

func (m *LayerParameter) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Phase_TRAIN
}

func (m *LayerParameter) GetLossWeight() []float32 {
	if m != nil {
		return m.LossWeight
	}
	return nil
}

func (m *LayerParameter) GetParam() []*ParamSpec {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *LayerParameter) GetInclude() []*NetStateRule {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *LayerParameter) GetExclude() []*NetStateRule {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *LayerParameter) GetTransformParam() *TransformationParameter {
	if m != nil {
		return m.TransformParam
	}
	return nil
}

func (m *LayerParameter) GetLossParam() *LossParameter {
	if m != nil {
		return m.LossParam
	}
	return nil
}

func (m *LayerParameter) GetAccuracyParam() *AccuracyParameter {
	if m != nil {
		return m.AccuracyParam
	}
	return nil
}

func (m *LayerParameter) GetArgmaxParam() *ArgMaxParameter {
	if m != nil {
		return m.ArgmaxParam
	}
	return nil
}

func (m *LayerParameter) GetConcatParam() *ConcatParameter {
	if m != nil {
		return m.ConcatParam
	}
	return nil
}

func (m *LayerParameter) GetContrastiveLossParam() *ContrastiveLossParameter {
	if m != nil {
		return m.ContrastiveLossParam
	}
	return nil
}

func (m *LayerParameter) GetConvolutionParam() *ConvolutionParameter {
	if m != nil {
		return m.ConvolutionParam
	}
	return nil
}

func (m *LayerParameter) GetDataParam() *DataParameter {
	if m != nil {
		return m.DataParam
	}
	return nil
}

func (m *LayerParameter) GetDropoutParam() *DropoutParameter {
	if m != nil {
		return m.DropoutParam
	}
	return nil
}

func (m *LayerParameter) GetDummyDataParam() *DummyDataParameter {
	if m != nil {
		return m.DummyDataParam
	}
	return nil
}

func (m *LayerParameter) GetEltwiseParam() *EltwiseParameter {
	if m != nil {
		return m.EltwiseParam
	}
	return nil
}

func (m *LayerParameter) GetExpParam() *ExpParameter {
	if m != nil {
		return m.ExpParam
	}
	return nil
}

func (m *LayerParameter) GetHdf5DataParam() *HDF5DataParameter {
	if m != nil {
		return m.Hdf5DataParam
	}
	return nil
}

func (m *LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

func (m *LayerParameter) GetHingeLossParam() *HingeLossParameter {
	if m != nil {
		return m.HingeLossParam
	}
	return nil
}

func (m *LayerParameter) GetImageDataParam() *ImageDataParameter {
	if m != nil {
		return m.ImageDataParam
	}
	return nil
}

func (m *LayerParameter) GetInfogainLossParam() *InfogainLossParameter {
	if m != nil {
		return m.InfogainLossParam
	}
	return nil
}

func (m *LayerParameter) GetInnerProductParam() *InnerProductParameter {
	if m != nil {
		return m.InnerProductParam
	}
	return nil
}

func (m *LayerParameter) GetLrnParam() *LRNParameter {
	if m != nil {
		return m.LrnParam
	}
	return nil
}

func (m *LayerParameter) GetMemoryDataParam() *MemoryDataParameter {
	if m != nil {
		return m.MemoryDataParam
	}
	return nil
}

func (m *LayerParameter) GetMvnParam() *MVNParameter {
	if m != nil {
		return m.MvnParam
	}
	return nil
}

func (m *LayerParameter) GetPoolingParam() *PoolingParameter {
	if m != nil {
		return m.PoolingParam
	}
	return nil
}

func (m *LayerParameter) GetPowerParam() *PowerParameter {
	if m != nil {
		return m.PowerParam
	}
	return nil
}

func (m *LayerParameter) GetPreluParam() *PReLUParameter {
	if m != nil {
		return m.PreluParam
	}
	return nil
}

func (m *LayerParameter) GetPythonParam() *PythonParameter {
	if m != nil {
		return m.PythonParam
	}
	return nil
}

func (m *LayerParameter) GetReluParam() *ReLUParameter {
	if m != nil {
		return m.ReluParam
	}
	return nil
}

func (m *LayerParameter) GetSigmoidParam() *SigmoidParameter {
	if m != nil {
		return m.SigmoidParam
	}
	return nil
}

func (m *LayerParameter) GetSoftmaxParam() *SoftmaxParameter {
	if m != nil {
		return m.SoftmaxParam
	}
	return nil
}

func (m *LayerParameter) GetSliceParam() *SliceParameter {
	if m != nil {
		return m.SliceParam
	}
	return nil
}

func (m *LayerParameter) GetTanhParam() *TanHParameter {
	if m != nil {
		return m.TanhParam
	}
	return nil
}

func (m *LayerParameter) GetThresholdParam() *ThresholdParameter {
	if m != nil {
		return m.ThresholdParam
	}
	return nil
}

func (m *LayerParameter) GetWindowDataParam() *WindowDataParameter {
	if m != nil {
		return m.WindowDataParam
	}
	return nil
}

// Message that stores parameters used to apply transformation
// to the data layer's data
type TransformationParameter struct {
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale *float32 `protobuf:"fixed32,1,opt,name=scale,def=1" json:"scale,omitempty"`
	// Specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,2,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Specify if we would like to randomly crop an image.
	CropSize *uint32 `protobuf:"varint,3,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// mean_file and mean_value cannot be specified at the same time
	MeanFile *string `protobuf:"bytes,4,opt,name=mean_file" json:"mean_file,omitempty"`
	// if specified can be repeated once (would substract it from all the channels)
	// or can be repeated the same number of times as channels
	// (would subtract them from the corresponding channel)
	MeanValue        []float32 `protobuf:"fixed32,5,rep,name=mean_value" json:"mean_value,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *TransformationParameter) Reset()                    { *m = TransformationParameter{} }
func (m *TransformationParameter) String() string            { return proto.CompactTextString(m) }
func (*TransformationParameter) ProtoMessage()               {}
func (*TransformationParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

const Default_TransformationParameter_Scale float32 = 1
const Default_TransformationParameter_Mirror bool = false
const Default_TransformationParameter_CropSize uint32 = 0

func (m *TransformationParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_TransformationParameter_Scale
}

func (m *TransformationParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_TransformationParameter_Mirror
}

func (m *TransformationParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_TransformationParameter_CropSize
}

func (m *TransformationParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *TransformationParameter) GetMeanValue() []float32 {
	if m != nil {
		return m.MeanValue
	}
	return nil
}

// Message that stores parameters shared by loss layers
type LossParameter struct {
	// If specified, ignore instances with the given label.
	IgnoreLabel *int32 `protobuf:"varint,1,opt,name=ignore_label" json:"ignore_label,omitempty"`
	// If true, normalize each batch across all instances (including spatial
	// dimesions, but not ignored instances); else, divide by batch size only.
	Normalize        *bool  `protobuf:"varint,2,opt,name=normalize,def=1" json:"normalize,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LossParameter) Reset()                    { *m = LossParameter{} }
func (m *LossParameter) String() string            { return proto.CompactTextString(m) }
func (*LossParameter) ProtoMessage()               {}
func (*LossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

const Default_LossParameter_Normalize bool = true

func (m *LossParameter) GetIgnoreLabel() int32 {
	if m != nil && m.IgnoreLabel != nil {
		return *m.IgnoreLabel
	}
	return 0
}

func (m *LossParameter) GetNormalize() bool {
	if m != nil && m.Normalize != nil {
		return *m.Normalize
	}
	return Default_LossParameter_Normalize
}

// Message that stores parameters used by AccuracyLayer
type AccuracyParameter struct {
	// When computing accuracy, count as correct by comparing the true label to
	// the top k scoring classes.  By default, only compare to the top scoring
	// class (i.e. argmax).
	TopK *uint32 `protobuf:"varint,1,opt,name=top_k,def=1" json:"top_k,omitempty"`
	// The "label" axis of the prediction blob, whose argmax corresponds to the
	// predicted label -- may be negative to index from the end (e.g., -1 for the
	// last axis).  For example, if axis == 1 and the predictions are
	// (N x C x H x W), the label blob is expected to contain N*H*W ground truth
	// labels with integer values in {0, 1, ..., C-1}.
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	// If specified, ignore instances with the given label.
	IgnoreLabel      *int32 `protobuf:"varint,3,opt,name=ignore_label" json:"ignore_label,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AccuracyParameter) Reset()                    { *m = AccuracyParameter{} }
func (m *AccuracyParameter) String() string            { return proto.CompactTextString(m) }
func (*AccuracyParameter) ProtoMessage()               {}
func (*AccuracyParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

const Default_AccuracyParameter_TopK uint32 = 1
const Default_AccuracyParameter_Axis int32 = 1

func (m *AccuracyParameter) GetTopK() uint32 {
	if m != nil && m.TopK != nil {
		return *m.TopK
	}
	return Default_AccuracyParameter_TopK
}

func (m *AccuracyParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_AccuracyParameter_Axis
}

func (m *AccuracyParameter) GetIgnoreLabel() int32 {
	if m != nil && m.IgnoreLabel != nil {
		return *m.IgnoreLabel
	}
	return 0
}

// Message that stores parameters used by ArgMaxLayer
type ArgMaxParameter struct {
	// If true produce pairs (argmax, maxval)
	OutMaxVal        *bool   `protobuf:"varint,1,opt,name=out_max_val,def=0" json:"out_max_val,omitempty"`
	TopK             *uint32 `protobuf:"varint,2,opt,name=top_k,def=1" json:"top_k,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ArgMaxParameter) Reset()                    { *m = ArgMaxParameter{} }
func (m *ArgMaxParameter) String() string            { return proto.CompactTextString(m) }
func (*ArgMaxParameter) ProtoMessage()               {}
func (*ArgMaxParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

const Default_ArgMaxParameter_OutMaxVal bool = false
const Default_ArgMaxParameter_TopK uint32 = 1

func (m *ArgMaxParameter) GetOutMaxVal() bool {
	if m != nil && m.OutMaxVal != nil {
		return *m.OutMaxVal
	}
	return Default_ArgMaxParameter_OutMaxVal
}

func (m *ArgMaxParameter) GetTopK() uint32 {
	if m != nil && m.TopK != nil {
		return *m.TopK
	}
	return Default_ArgMaxParameter_TopK
}

// Message that stores parameters used by ConcatLayer
type ConcatParameter struct {
	// The axis along which to concatenate -- may be negative to index from the
	// end (e.g., -1 for the last axis).  Other axes must have the
	// same dimension for all the bottom blobs.
	// By default, ConcatLayer concatenates blobs along the "channels" axis (1).
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	// DEPRECATED: alias for "axis" -- does not support negative indexing.
	ConcatDim        *uint32 `protobuf:"varint,1,opt,name=concat_dim,def=1" json:"concat_dim,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ConcatParameter) Reset()                    { *m = ConcatParameter{} }
func (m *ConcatParameter) String() string            { return proto.CompactTextString(m) }
func (*ConcatParameter) ProtoMessage()               {}
func (*ConcatParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

const Default_ConcatParameter_Axis int32 = 1
const Default_ConcatParameter_ConcatDim uint32 = 1

func (m *ConcatParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ConcatParameter_Axis
}

func (m *ConcatParameter) GetConcatDim() uint32 {
	if m != nil && m.ConcatDim != nil {
		return *m.ConcatDim
	}
	return Default_ConcatParameter_ConcatDim
}

// Message that stores parameters used by ContrastiveLossLayer
type ContrastiveLossParameter struct {
	// margin for dissimilar pair
	Margin           *float32 `protobuf:"fixed32,1,opt,name=margin,def=1" json:"margin,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ContrastiveLossParameter) Reset()                    { *m = ContrastiveLossParameter{} }
func (m *ContrastiveLossParameter) String() string            { return proto.CompactTextString(m) }
func (*ContrastiveLossParameter) ProtoMessage()               {}
func (*ContrastiveLossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

const Default_ContrastiveLossParameter_Margin float32 = 1

func (m *ContrastiveLossParameter) GetMargin() float32 {
	if m != nil && m.Margin != nil {
		return *m.Margin
	}
	return Default_ContrastiveLossParameter_Margin
}

// Message that stores parameters used by ConvolutionLayer
type ConvolutionParameter struct {
	NumOutput *uint32 `protobuf:"varint,1,opt,name=num_output" json:"num_output,omitempty"`
	BiasTerm  *bool   `protobuf:"varint,2,opt,name=bias_term,def=1" json:"bias_term,omitempty"`
	// Pad, kernel size, and stride are all given as a single value for equal
	// dimensions in height and width or as Y, X pairs.
	Pad              *uint32                      `protobuf:"varint,3,opt,name=pad,def=0" json:"pad,omitempty"`
	PadH             *uint32                      `protobuf:"varint,9,opt,name=pad_h,def=0" json:"pad_h,omitempty"`
	PadW             *uint32                      `protobuf:"varint,10,opt,name=pad_w,def=0" json:"pad_w,omitempty"`
	KernelSize       *uint32                      `protobuf:"varint,4,opt,name=kernel_size" json:"kernel_size,omitempty"`
	KernelH          *uint32                      `protobuf:"varint,11,opt,name=kernel_h" json:"kernel_h,omitempty"`
	KernelW          *uint32                      `protobuf:"varint,12,opt,name=kernel_w" json:"kernel_w,omitempty"`
	Group            *uint32                      `protobuf:"varint,5,opt,name=group,def=1" json:"group,omitempty"`
	Stride           *uint32                      `protobuf:"varint,6,opt,name=stride,def=1" json:"stride,omitempty"`
	StrideH          *uint32                      `protobuf:"varint,13,opt,name=stride_h" json:"stride_h,omitempty"`
	StrideW          *uint32                      `protobuf:"varint,14,opt,name=stride_w" json:"stride_w,omitempty"`
	WeightFiller     *FillerParameter             `protobuf:"bytes,7,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller       *FillerParameter             `protobuf:"bytes,8,opt,name=bias_filler" json:"bias_filler,omitempty"`
	Engine           *ConvolutionParameter_Engine `protobuf:"varint,15,opt,name=engine,enum=caffe.ConvolutionParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *ConvolutionParameter) Reset()                    { *m = ConvolutionParameter{} }
func (m *ConvolutionParameter) String() string            { return proto.CompactTextString(m) }
func (*ConvolutionParameter) ProtoMessage()               {}
func (*ConvolutionParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

const Default_ConvolutionParameter_BiasTerm bool = true
const Default_ConvolutionParameter_Pad uint32 = 0
const Default_ConvolutionParameter_PadH uint32 = 0
const Default_ConvolutionParameter_PadW uint32 = 0
const Default_ConvolutionParameter_Group uint32 = 1
const Default_ConvolutionParameter_Stride uint32 = 1
const Default_ConvolutionParameter_Engine ConvolutionParameter_Engine = ConvolutionParameter_DEFAULT

func (m *ConvolutionParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *ConvolutionParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_ConvolutionParameter_BiasTerm
}

func (m *ConvolutionParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_ConvolutionParameter_Pad
}

func (m *ConvolutionParameter) GetPadH() uint32 {
	if m != nil && m.PadH != nil {
		return *m.PadH
	}
	return Default_ConvolutionParameter_PadH
}

func (m *ConvolutionParameter) GetPadW() uint32 {
	if m != nil && m.PadW != nil {
		return *m.PadW
	}
	return Default_ConvolutionParameter_PadW
}

func (m *ConvolutionParameter) GetKernelSize() uint32 {
	if m != nil && m.KernelSize != nil {
		return *m.KernelSize
	}
	return 0
}

func (m *ConvolutionParameter) GetKernelH() uint32 {
	if m != nil && m.KernelH != nil {
		return *m.KernelH
	}
	return 0
}

func (m *ConvolutionParameter) GetKernelW() uint32 {
	if m != nil && m.KernelW != nil {
		return *m.KernelW
	}
	return 0
}

func (m *ConvolutionParameter) GetGroup() uint32 {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Default_ConvolutionParameter_Group
}

func (m *ConvolutionParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_ConvolutionParameter_Stride
}

func (m *ConvolutionParameter) GetStrideH() uint32 {
	if m != nil && m.StrideH != nil {
		return *m.StrideH
	}
	return 0
}

func (m *ConvolutionParameter) GetStrideW() uint32 {
	if m != nil && m.StrideW != nil {
		return *m.StrideW
	}
	return 0
}

func (m *ConvolutionParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *ConvolutionParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *ConvolutionParameter) GetEngine() ConvolutionParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_ConvolutionParameter_Engine
}

// Message that stores parameters used by DataLayer
type DataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size" json:"batch_size,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32           `protobuf:"varint,7,opt,name=rand_skip,def=0" json:"rand_skip,omitempty"`
	Backend  *DataParameter_DB `protobuf:"varint,8,opt,name=backend,enum=caffe.DataParameter_DB,def=0" json:"backend,omitempty"`
	// DEPRECATED. See TransformationParameter. For data pre-processing, we can do
	// simple scaling and subtracting the data mean, if provided. Note that the
	// mean subtraction is always carried out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile *string  `protobuf:"bytes,3,opt,name=mean_file" json:"mean_file,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we would like to randomly
	// crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
	// data.
	Mirror *bool `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Force the encoded image to have 3 color channels
	ForceEncodedColor *bool  `protobuf:"varint,9,opt,name=force_encoded_color,def=0" json:"force_encoded_color,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *DataParameter) Reset()                    { *m = DataParameter{} }
func (m *DataParameter) String() string            { return proto.CompactTextString(m) }
func (*DataParameter) ProtoMessage()               {}
func (*DataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

const Default_DataParameter_RandSkip uint32 = 0
const Default_DataParameter_Backend DataParameter_DB = DataParameter_LEVELDB
const Default_DataParameter_Scale float32 = 1
const Default_DataParameter_CropSize uint32 = 0
const Default_DataParameter_Mirror bool = false
const Default_DataParameter_ForceEncodedColor bool = false

func (m *DataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *DataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *DataParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_DataParameter_RandSkip
}

func (m *DataParameter) GetBackend() DataParameter_DB {
	if m != nil && m.Backend != nil {
		return *m.Backend
	}
	return Default_DataParameter_Backend
}

func (m *DataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_DataParameter_Scale
}

func (m *DataParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *DataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_DataParameter_CropSize
}

func (m *DataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_DataParameter_Mirror
}

func (m *DataParameter) GetForceEncodedColor() bool {
	if m != nil && m.ForceEncodedColor != nil {
		return *m.ForceEncodedColor
	}
	return Default_DataParameter_ForceEncodedColor
}

// Message that stores parameters used by DropoutLayer
type DropoutParameter struct {
	DropoutRatio     *float32 `protobuf:"fixed32,1,opt,name=dropout_ratio,def=0.5" json:"dropout_ratio,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DropoutParameter) Reset()                    { *m = DropoutParameter{} }
func (m *DropoutParameter) String() string            { return proto.CompactTextString(m) }
func (*DropoutParameter) ProtoMessage()               {}
func (*DropoutParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

const Default_DropoutParameter_DropoutRatio float32 = 0.5

func (m *DropoutParameter) GetDropoutRatio() float32 {
	if m != nil && m.DropoutRatio != nil {
		return *m.DropoutRatio
	}
	return Default_DropoutParameter_DropoutRatio
}

// Message that stores parameters used by DummyDataLayer.
// DummyDataLayer fills any number of arbitrarily shaped blobs with random
// (or constant) data generated by "Fillers" (see "message FillerParameter").
type DummyDataParameter struct {
	// This layer produces N >= 1 top blobs.  DummyDataParameter must specify 1 or N
	// shape fields, and 0, 1 or N data_fillers.
	//
	// If 0 data_fillers are specified, ConstantFiller with a value of 0 is used.
	// If 1 data_filler is specified, it is applied to all top blobs.  If N are
	// specified, the ith is applied to the ith top blob.
	DataFiller []*FillerParameter `protobuf:"bytes,1,rep,name=data_filler" json:"data_filler,omitempty"`
	Shape      []*BlobShape       `protobuf:"bytes,6,rep,name=shape" json:"shape,omitempty"`
	// 4D dimensions -- deprecated.  Use "shape" instead.
	Num              []uint32 `protobuf:"varint,2,rep,name=num" json:"num,omitempty"`
	Channels         []uint32 `protobuf:"varint,3,rep,name=channels" json:"channels,omitempty"`
	Height           []uint32 `protobuf:"varint,4,rep,name=height" json:"height,omitempty"`
	Width            []uint32 `protobuf:"varint,5,rep,name=width" json:"width,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DummyDataParameter) Reset()                    { *m = DummyDataParameter{} }
func (m *DummyDataParameter) String() string            { return proto.CompactTextString(m) }
func (*DummyDataParameter) ProtoMessage()               {}
func (*DummyDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *DummyDataParameter) GetDataFiller() []*FillerParameter {
	if m != nil {
		return m.DataFiller
	}
	return nil
}

func (m *DummyDataParameter) GetShape() []*BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *DummyDataParameter) GetNum() []uint32 {
	if m != nil {
		return m.Num
	}
	return nil
}

func (m *DummyDataParameter) GetChannels() []uint32 {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *DummyDataParameter) GetHeight() []uint32 {
	if m != nil {
		return m.Height
	}
	return nil
}

func (m *DummyDataParameter) GetWidth() []uint32 {
	if m != nil {
		return m.Width
	}
	return nil
}

// Message that stores parameters used by EltwiseLayer
type EltwiseParameter struct {
	Operation *EltwiseParameter_EltwiseOp `protobuf:"varint,1,opt,name=operation,enum=caffe.EltwiseParameter_EltwiseOp,def=1" json:"operation,omitempty"`
	Coeff     []float32                   `protobuf:"fixed32,2,rep,name=coeff" json:"coeff,omitempty"`
	// Whether to use an asymptotically slower (for >2 inputs) but stabler method
	// of computing the gradient for the PROD operation. (No effect for SUM op.)
	StableProdGrad   *bool  `protobuf:"varint,3,opt,name=stable_prod_grad,def=1" json:"stable_prod_grad,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EltwiseParameter) Reset()                    { *m = EltwiseParameter{} }
func (m *EltwiseParameter) String() string            { return proto.CompactTextString(m) }
func (*EltwiseParameter) ProtoMessage()               {}
func (*EltwiseParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

const Default_EltwiseParameter_Operation EltwiseParameter_EltwiseOp = EltwiseParameter_SUM
const Default_EltwiseParameter_StableProdGrad bool = true

func (m *EltwiseParameter) GetOperation() EltwiseParameter_EltwiseOp {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return Default_EltwiseParameter_Operation
}

func (m *EltwiseParameter) GetCoeff() []float32 {
	if m != nil {
		return m.Coeff
	}
	return nil
}

func (m *EltwiseParameter) GetStableProdGrad() bool {
	if m != nil && m.StableProdGrad != nil {
		return *m.StableProdGrad
	}
	return Default_EltwiseParameter_StableProdGrad
}

// Message that stores parameters used by ExpLayer
type ExpParameter struct {
	// ExpLayer computes outputs y = base ^ (shift + scale * x), for base > 0.
	// Or if base is set to the default (-1), base is set to e,
	// so y = exp(shift + scale * x).
	Base             *float32 `protobuf:"fixed32,1,opt,name=base,def=-1" json:"base,omitempty"`
	Scale            *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift            *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ExpParameter) Reset()                    { *m = ExpParameter{} }
func (m *ExpParameter) String() string            { return proto.CompactTextString(m) }
func (*ExpParameter) ProtoMessage()               {}
func (*ExpParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

const Default_ExpParameter_Base float32 = -1
const Default_ExpParameter_Scale float32 = 1
const Default_ExpParameter_Shift float32 = 0

func (m *ExpParameter) GetBase() float32 {
	if m != nil && m.Base != nil {
		return *m.Base
	}
	return Default_ExpParameter_Base
}

func (m *ExpParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_ExpParameter_Scale
}

func (m *ExpParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_ExpParameter_Shift
}

// Message that stores parameters used by HDF5DataLayer
type HDF5DataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,2,opt,name=batch_size" json:"batch_size,omitempty"`
	// Specify whether to shuffle the data.
	// If shuffle == true, the ordering of the HDF5 files is shuffled,
	// and the ordering of data within any given HDF5 file is shuffled,
	// but data between different files are not interleaved; all of a file's
	// data are output (in a random order) before moving onto another file.
	Shuffle          *bool  `protobuf:"varint,3,opt,name=shuffle,def=0" json:"shuffle,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *HDF5DataParameter) Reset()                    { *m = HDF5DataParameter{} }
func (m *HDF5DataParameter) String() string            { return proto.CompactTextString(m) }
func (*HDF5DataParameter) ProtoMessage()               {}
func (*HDF5DataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

const Default_HDF5DataParameter_Shuffle bool = false

func (m *HDF5DataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *HDF5DataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *HDF5DataParameter) GetShuffle() bool {
	if m != nil && m.Shuffle != nil {
		return *m.Shuffle
	}
	return Default_HDF5DataParameter_Shuffle
}

// Message that stores parameters used by HDF5OutputLayer
type HDF5OutputParameter struct {
	FileName         *string `protobuf:"bytes,1,opt,name=file_name" json:"file_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HDF5OutputParameter) Reset()                    { *m = HDF5OutputParameter{} }
func (m *HDF5OutputParameter) String() string            { return proto.CompactTextString(m) }
func (*HDF5OutputParameter) ProtoMessage()               {}
func (*HDF5OutputParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *HDF5OutputParameter) GetFileName() string {
	if m != nil && m.FileName != nil {
		return *m.FileName
	}
	return ""
}

type HingeLossParameter struct {
	// Specify the Norm to use L1 or L2
	Norm             *HingeLossParameter_Norm `protobuf:"varint,1,opt,name=norm,enum=caffe.HingeLossParameter_Norm,def=1" json:"norm,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *HingeLossParameter) Reset()                    { *m = HingeLossParameter{} }
func (m *HingeLossParameter) String() string            { return proto.CompactTextString(m) }
func (*HingeLossParameter) ProtoMessage()               {}
func (*HingeLossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

const Default_HingeLossParameter_Norm HingeLossParameter_Norm = HingeLossParameter_L1

func (m *HingeLossParameter) GetNorm() HingeLossParameter_Norm {
	if m != nil && m.Norm != nil {
		return *m.Norm
	}
	return Default_HingeLossParameter_Norm
}

// Message that stores parameters used by ImageDataLayer
type ImageDataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size" json:"batch_size,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32 `protobuf:"varint,7,opt,name=rand_skip,def=0" json:"rand_skip,omitempty"`
	// Whether or not ImageLayer should shuffle the list of files at every epoch.
	Shuffle *bool `protobuf:"varint,8,opt,name=shuffle,def=0" json:"shuffle,omitempty"`
	// It will also resize images if new_height or new_width are not zero.
	NewHeight *uint32 `protobuf:"varint,9,opt,name=new_height,def=0" json:"new_height,omitempty"`
	NewWidth  *uint32 `protobuf:"varint,10,opt,name=new_width,def=0" json:"new_width,omitempty"`
	// Specify if the images are color or gray
	IsColor *bool `protobuf:"varint,11,opt,name=is_color,def=1" json:"is_color,omitempty"`
	// DEPRECATED. See TransformationParameter. For data pre-processing, we can do
	// simple scaling and subtracting the data mean, if provided. Note that the
	// mean subtraction is always carried out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile *string  `protobuf:"bytes,3,opt,name=mean_file" json:"mean_file,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we would like to randomly
	// crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
	// data.
	Mirror           *bool   `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	RootFolder       *string `protobuf:"bytes,12,opt,name=root_folder,def=" json:"root_folder,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ImageDataParameter) Reset()                    { *m = ImageDataParameter{} }
func (m *ImageDataParameter) String() string            { return proto.CompactTextString(m) }
func (*ImageDataParameter) ProtoMessage()               {}
func (*ImageDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

const Default_ImageDataParameter_RandSkip uint32 = 0
const Default_ImageDataParameter_Shuffle bool = false
const Default_ImageDataParameter_NewHeight uint32 = 0
const Default_ImageDataParameter_NewWidth uint32 = 0
const Default_ImageDataParameter_IsColor bool = true
const Default_ImageDataParameter_Scale float32 = 1
const Default_ImageDataParameter_CropSize uint32 = 0
const Default_ImageDataParameter_Mirror bool = false

func (m *ImageDataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *ImageDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *ImageDataParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_ImageDataParameter_RandSkip
}

func (m *ImageDataParameter) GetShuffle() bool {
	if m != nil && m.Shuffle != nil {
		return *m.Shuffle
	}
	return Default_ImageDataParameter_Shuffle
}

func (m *ImageDataParameter) GetNewHeight() uint32 {
	if m != nil && m.NewHeight != nil {
		return *m.NewHeight
	}
	return Default_ImageDataParameter_NewHeight
}

func (m *ImageDataParameter) GetNewWidth() uint32 {
	if m != nil && m.NewWidth != nil {
		return *m.NewWidth
	}
	return Default_ImageDataParameter_NewWidth
}

func (m *ImageDataParameter) GetIsColor() bool {
	if m != nil && m.IsColor != nil {
		return *m.IsColor
	}
	return Default_ImageDataParameter_IsColor
}

func (m *ImageDataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_ImageDataParameter_Scale
}

func (m *ImageDataParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *ImageDataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_ImageDataParameter_CropSize
}

func (m *ImageDataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_ImageDataParameter_Mirror
}

func (m *ImageDataParameter) GetRootFolder() string {
	if m != nil && m.RootFolder != nil {
		return *m.RootFolder
	}
	return ""
}

// Message that stores parameters InfogainLossLayer
type InfogainLossParameter struct {
	// Specify the infogain matrix source.
	Source           *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *InfogainLossParameter) Reset()                    { *m = InfogainLossParameter{} }
func (m *InfogainLossParameter) String() string            { return proto.CompactTextString(m) }
func (*InfogainLossParameter) ProtoMessage()               {}
func (*InfogainLossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *InfogainLossParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

// Message that stores parameters used by InnerProductLayer
type InnerProductParameter struct {
	NumOutput    *uint32          `protobuf:"varint,1,opt,name=num_output" json:"num_output,omitempty"`
	BiasTerm     *bool            `protobuf:"varint,2,opt,name=bias_term,def=1" json:"bias_term,omitempty"`
	WeightFiller *FillerParameter `protobuf:"bytes,3,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter `protobuf:"bytes,4,opt,name=bias_filler" json:"bias_filler,omitempty"`
	// The first axis to be lumped into a single inner product computation;
	// all preceding axes are retained in the output.
	// May be negative to index from the end (e.g., -1 for the last axis).
	Axis             *int32 `protobuf:"varint,5,opt,name=axis,def=1" json:"axis,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InnerProductParameter) Reset()                    { *m = InnerProductParameter{} }
func (m *InnerProductParameter) String() string            { return proto.CompactTextString(m) }
func (*InnerProductParameter) ProtoMessage()               {}
func (*InnerProductParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

const Default_InnerProductParameter_BiasTerm bool = true
const Default_InnerProductParameter_Axis int32 = 1

func (m *InnerProductParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *InnerProductParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_InnerProductParameter_BiasTerm
}

func (m *InnerProductParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *InnerProductParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *InnerProductParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_InnerProductParameter_Axis
}

// Message that stores parameters used by LRNLayer
type LRNParameter struct {
	LocalSize        *uint32                  `protobuf:"varint,1,opt,name=local_size,def=5" json:"local_size,omitempty"`
	Alpha            *float32                 `protobuf:"fixed32,2,opt,name=alpha,def=1" json:"alpha,omitempty"`
	Beta             *float32                 `protobuf:"fixed32,3,opt,name=beta,def=0.75" json:"beta,omitempty"`
	NormRegion       *LRNParameter_NormRegion `protobuf:"varint,4,opt,name=norm_region,enum=caffe.LRNParameter_NormRegion,def=0" json:"norm_region,omitempty"`
	K                *float32                 `protobuf:"fixed32,5,opt,name=k,def=1" json:"k,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *LRNParameter) Reset()                    { *m = LRNParameter{} }
func (m *LRNParameter) String() string            { return proto.CompactTextString(m) }
func (*LRNParameter) ProtoMessage()               {}
func (*LRNParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

const Default_LRNParameter_LocalSize uint32 = 5
const Default_LRNParameter_Alpha float32 = 1
const Default_LRNParameter_Beta float32 = 0.75
const Default_LRNParameter_NormRegion LRNParameter_NormRegion = LRNParameter_ACROSS_CHANNELS
const Default_LRNParameter_K float32 = 1

func (m *LRNParameter) GetLocalSize() uint32 {
	if m != nil && m.LocalSize != nil {
		return *m.LocalSize
	}
	return Default_LRNParameter_LocalSize
}

func (m *LRNParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_LRNParameter_Alpha
}

func (m *LRNParameter) GetBeta() float32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return Default_LRNParameter_Beta
}

func (m *LRNParameter) GetNormRegion() LRNParameter_NormRegion {
	if m != nil && m.NormRegion != nil {
		return *m.NormRegion
	}
	return Default_LRNParameter_NormRegion
}

func (m *LRNParameter) GetK() float32 {
	if m != nil && m.K != nil {
		return *m.K
	}
	return Default_LRNParameter_K
}

// Message that stores parameters used by MemoryDataLayer
type MemoryDataParameter struct {
	BatchSize        *uint32 `protobuf:"varint,1,opt,name=batch_size" json:"batch_size,omitempty"`
	Channels         *uint32 `protobuf:"varint,2,opt,name=channels" json:"channels,omitempty"`
	Height           *uint32 `protobuf:"varint,3,opt,name=height" json:"height,omitempty"`
	Width            *uint32 `protobuf:"varint,4,opt,name=width" json:"width,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MemoryDataParameter) Reset()                    { *m = MemoryDataParameter{} }
func (m *MemoryDataParameter) String() string            { return proto.CompactTextString(m) }
func (*MemoryDataParameter) ProtoMessage()               {}
func (*MemoryDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *MemoryDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *MemoryDataParameter) GetChannels() uint32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return 0
}

func (m *MemoryDataParameter) GetHeight() uint32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *MemoryDataParameter) GetWidth() uint32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

// Message that stores parameters used by MVNLayer
type MVNParameter struct {
	// This parameter can be set to false to normalize mean only
	NormalizeVariance *bool `protobuf:"varint,1,opt,name=normalize_variance,def=1" json:"normalize_variance,omitempty"`
	// This parameter can be set to true to perform DNN-like MVN
	AcrossChannels   *bool  `protobuf:"varint,2,opt,name=across_channels,def=0" json:"across_channels,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MVNParameter) Reset()                    { *m = MVNParameter{} }
func (m *MVNParameter) String() string            { return proto.CompactTextString(m) }
func (*MVNParameter) ProtoMessage()               {}
func (*MVNParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

const Default_MVNParameter_NormalizeVariance bool = true
const Default_MVNParameter_AcrossChannels bool = false

func (m *MVNParameter) GetNormalizeVariance() bool {
	if m != nil && m.NormalizeVariance != nil {
		return *m.NormalizeVariance
	}
	return Default_MVNParameter_NormalizeVariance
}

func (m *MVNParameter) GetAcrossChannels() bool {
	if m != nil && m.AcrossChannels != nil {
		return *m.AcrossChannels
	}
	return Default_MVNParameter_AcrossChannels
}

// Message that stores parameters used by PoolingLayer
type PoolingParameter struct {
	Pool *PoolingParameter_PoolMethod `protobuf:"varint,1,opt,name=pool,enum=caffe.PoolingParameter_PoolMethod,def=0" json:"pool,omitempty"`
	// Pad, kernel size, and stride are all given as a single value for equal
	// dimensions in height and width or as Y, X pairs.
	Pad        *uint32                  `protobuf:"varint,4,opt,name=pad,def=0" json:"pad,omitempty"`
	PadH       *uint32                  `protobuf:"varint,9,opt,name=pad_h,def=0" json:"pad_h,omitempty"`
	PadW       *uint32                  `protobuf:"varint,10,opt,name=pad_w,def=0" json:"pad_w,omitempty"`
	KernelSize *uint32                  `protobuf:"varint,2,opt,name=kernel_size" json:"kernel_size,omitempty"`
	KernelH    *uint32                  `protobuf:"varint,5,opt,name=kernel_h" json:"kernel_h,omitempty"`
	KernelW    *uint32                  `protobuf:"varint,6,opt,name=kernel_w" json:"kernel_w,omitempty"`
	Stride     *uint32                  `protobuf:"varint,3,opt,name=stride,def=1" json:"stride,omitempty"`
	StrideH    *uint32                  `protobuf:"varint,7,opt,name=stride_h" json:"stride_h,omitempty"`
	StrideW    *uint32                  `protobuf:"varint,8,opt,name=stride_w" json:"stride_w,omitempty"`
	Engine     *PoolingParameter_Engine `protobuf:"varint,11,opt,name=engine,enum=caffe.PoolingParameter_Engine,def=0" json:"engine,omitempty"`
	// If global_pooling then it will pool over the size of the bottom by doing
	// kernel_h = bottom->height and kernel_w = bottom->width
	GlobalPooling    *bool  `protobuf:"varint,12,opt,name=global_pooling,def=0" json:"global_pooling,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PoolingParameter) Reset()                    { *m = PoolingParameter{} }
func (m *PoolingParameter) String() string            { return proto.CompactTextString(m) }
func (*PoolingParameter) ProtoMessage()               {}
func (*PoolingParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

const Default_PoolingParameter_Pool PoolingParameter_PoolMethod = PoolingParameter_MAX
const Default_PoolingParameter_Pad uint32 = 0
const Default_PoolingParameter_PadH uint32 = 0
const Default_PoolingParameter_PadW uint32 = 0
const Default_PoolingParameter_Stride uint32 = 1
const Default_PoolingParameter_Engine PoolingParameter_Engine = PoolingParameter_DEFAULT
const Default_PoolingParameter_GlobalPooling bool = false

func (m *PoolingParameter) GetPool() PoolingParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_PoolingParameter_Pool
}

func (m *PoolingParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_PoolingParameter_Pad
}

func (m *PoolingParameter) GetPadH() uint32 {
	if m != nil && m.PadH != nil {
		return *m.PadH
	}
	return Default_PoolingParameter_PadH
}

func (m *PoolingParameter) GetPadW() uint32 {
	if m != nil && m.PadW != nil {
		return *m.PadW
	}
	return Default_PoolingParameter_PadW
}

func (m *PoolingParameter) GetKernelSize() uint32 {
	if m != nil && m.KernelSize != nil {
		return *m.KernelSize
	}
	return 0
}

func (m *PoolingParameter) GetKernelH() uint32 {
	if m != nil && m.KernelH != nil {
		return *m.KernelH
	}
	return 0
}

func (m *PoolingParameter) GetKernelW() uint32 {
	if m != nil && m.KernelW != nil {
		return *m.KernelW
	}
	return 0
}

func (m *PoolingParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_PoolingParameter_Stride
}

func (m *PoolingParameter) GetStrideH() uint32 {
	if m != nil && m.StrideH != nil {
		return *m.StrideH
	}
	return 0
}

func (m *PoolingParameter) GetStrideW() uint32 {
	if m != nil && m.StrideW != nil {
		return *m.StrideW
	}
	return 0
}

func (m *PoolingParameter) GetEngine() PoolingParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_PoolingParameter_Engine
}

func (m *PoolingParameter) GetGlobalPooling() bool {
	if m != nil && m.GlobalPooling != nil {
		return *m.GlobalPooling
	}
	return Default_PoolingParameter_GlobalPooling
}

// Message that stores parameters used by PowerLayer
type PowerParameter struct {
	// PowerLayer computes outputs y = (shift + scale * x) ^ power.
	Power            *float32 `protobuf:"fixed32,1,opt,name=power,def=1" json:"power,omitempty"`
	Scale            *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift            *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PowerParameter) Reset()                    { *m = PowerParameter{} }
func (m *PowerParameter) String() string            { return proto.CompactTextString(m) }
func (*PowerParameter) ProtoMessage()               {}
func (*PowerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

const Default_PowerParameter_Power float32 = 1
const Default_PowerParameter_Scale float32 = 1
const Default_PowerParameter_Shift float32 = 0

func (m *PowerParameter) GetPower() float32 {
	if m != nil && m.Power != nil {
		return *m.Power
	}
	return Default_PowerParameter_Power
}

func (m *PowerParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_PowerParameter_Scale
}

func (m *PowerParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_PowerParameter_Shift
}

// Message that stores parameters used by PythonLayer
type PythonParameter struct {
	Module           *string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
	Layer            *string `protobuf:"bytes,2,opt,name=layer" json:"layer,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PythonParameter) Reset()                    { *m = PythonParameter{} }
func (m *PythonParameter) String() string            { return proto.CompactTextString(m) }
func (*PythonParameter) ProtoMessage()               {}
func (*PythonParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *PythonParameter) GetModule() string {
	if m != nil && m.Module != nil {
		return *m.Module
	}
	return ""
}

func (m *PythonParameter) GetLayer() string {
	if m != nil && m.Layer != nil {
		return *m.Layer
	}
	return ""
}

// Message that stores parameters used by ReLULayer
type ReLUParameter struct {
	// Allow non-zero slope for negative inputs to speed up optimization
	// Described in:
	// Maas, A. L., Hannun, A. Y., & Ng, A. Y. (2013). Rectifier nonlinearities
	// improve neural network acoustic models. In ICML Workshop on Deep Learning
	// for Audio, Speech, and Language Processing.
	NegativeSlope    *float32              `protobuf:"fixed32,1,opt,name=negative_slope,def=0" json:"negative_slope,omitempty"`
	Engine           *ReLUParameter_Engine `protobuf:"varint,2,opt,name=engine,enum=caffe.ReLUParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *ReLUParameter) Reset()                    { *m = ReLUParameter{} }
func (m *ReLUParameter) String() string            { return proto.CompactTextString(m) }
func (*ReLUParameter) ProtoMessage()               {}
func (*ReLUParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

const Default_ReLUParameter_NegativeSlope float32 = 0
const Default_ReLUParameter_Engine ReLUParameter_Engine = ReLUParameter_DEFAULT

func (m *ReLUParameter) GetNegativeSlope() float32 {
	if m != nil && m.NegativeSlope != nil {
		return *m.NegativeSlope
	}
	return Default_ReLUParameter_NegativeSlope
}

func (m *ReLUParameter) GetEngine() ReLUParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_ReLUParameter_Engine
}

// Message that stores parameters used by SigmoidLayer
type SigmoidParameter struct {
	Engine           *SigmoidParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=caffe.SigmoidParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *SigmoidParameter) Reset()                    { *m = SigmoidParameter{} }
func (m *SigmoidParameter) String() string            { return proto.CompactTextString(m) }
func (*SigmoidParameter) ProtoMessage()               {}
func (*SigmoidParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

const Default_SigmoidParameter_Engine SigmoidParameter_Engine = SigmoidParameter_DEFAULT

func (m *SigmoidParameter) GetEngine() SigmoidParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SigmoidParameter_Engine
}

// Message that stores parameters used by SliceLayer
type SliceParameter struct {
	// The axis along which to slice -- may be negative to index from the end
	// (e.g., -1 for the last axis).
	// By default, SliceLayer concatenates blobs along the "channels" axis (1).
	Axis       *int32   `protobuf:"varint,3,opt,name=axis,def=1" json:"axis,omitempty"`
	SlicePoint []uint32 `protobuf:"varint,2,rep,name=slice_point" json:"slice_point,omitempty"`
	// DEPRECATED: alias for "axis" -- does not support negative indexing.
	SliceDim         *uint32 `protobuf:"varint,1,opt,name=slice_dim,def=1" json:"slice_dim,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SliceParameter) Reset()                    { *m = SliceParameter{} }
func (m *SliceParameter) String() string            { return proto.CompactTextString(m) }
func (*SliceParameter) ProtoMessage()               {}
func (*SliceParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

const Default_SliceParameter_Axis int32 = 1
const Default_SliceParameter_SliceDim uint32 = 1

func (m *SliceParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_SliceParameter_Axis
}

func (m *SliceParameter) GetSlicePoint() []uint32 {
	if m != nil {
		return m.SlicePoint
	}
	return nil
}

func (m *SliceParameter) GetSliceDim() uint32 {
	if m != nil && m.SliceDim != nil {
		return *m.SliceDim
	}
	return Default_SliceParameter_SliceDim
}

// Message that stores parameters used by SoftmaxLayer, SoftmaxWithLossLayer
type SoftmaxParameter struct {
	Engine *SoftmaxParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=caffe.SoftmaxParameter_Engine,def=0" json:"engine,omitempty"`
	// The axis along which to perform the softmax -- may be negative to index
	// from the end (e.g., -1 for the last axis).
	// Any other axes will be evaluated as independent softmaxes.
	Axis             *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SoftmaxParameter) Reset()                    { *m = SoftmaxParameter{} }
func (m *SoftmaxParameter) String() string            { return proto.CompactTextString(m) }
func (*SoftmaxParameter) ProtoMessage()               {}
func (*SoftmaxParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

const Default_SoftmaxParameter_Engine SoftmaxParameter_Engine = SoftmaxParameter_DEFAULT
const Default_SoftmaxParameter_Axis int32 = 1

func (m *SoftmaxParameter) GetEngine() SoftmaxParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SoftmaxParameter_Engine
}

func (m *SoftmaxParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_SoftmaxParameter_Axis
}

// Message that stores parameters used by TanHLayer
type TanHParameter struct {
	Engine           *TanHParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=caffe.TanHParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TanHParameter) Reset()                    { *m = TanHParameter{} }
func (m *TanHParameter) String() string            { return proto.CompactTextString(m) }
func (*TanHParameter) ProtoMessage()               {}
func (*TanHParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

const Default_TanHParameter_Engine TanHParameter_Engine = TanHParameter_DEFAULT

func (m *TanHParameter) GetEngine() TanHParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_TanHParameter_Engine
}

// Message that stores parameters used by ThresholdLayer
type ThresholdParameter struct {
	Threshold        *float32 `protobuf:"fixed32,1,opt,name=threshold,def=0" json:"threshold,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ThresholdParameter) Reset()                    { *m = ThresholdParameter{} }
func (m *ThresholdParameter) String() string            { return proto.CompactTextString(m) }
func (*ThresholdParameter) ProtoMessage()               {}
func (*ThresholdParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

const Default_ThresholdParameter_Threshold float32 = 0

func (m *ThresholdParameter) GetThreshold() float32 {
	if m != nil && m.Threshold != nil {
		return *m.Threshold
	}
	return Default_ThresholdParameter_Threshold
}

// Message that stores parameters used by WindowDataLayer
type WindowDataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile *string  `protobuf:"bytes,3,opt,name=mean_file" json:"mean_file,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size" json:"batch_size,omitempty"`
	// Specify if we would like to randomly crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// Specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Foreground (object) overlap threshold
	FgThreshold *float32 `protobuf:"fixed32,7,opt,name=fg_threshold,def=0.5" json:"fg_threshold,omitempty"`
	// Background (non-object) overlap threshold
	BgThreshold *float32 `protobuf:"fixed32,8,opt,name=bg_threshold,def=0.5" json:"bg_threshold,omitempty"`
	// Fraction of batch that should be foreground objects
	FgFraction *float32 `protobuf:"fixed32,9,opt,name=fg_fraction,def=0.25" json:"fg_fraction,omitempty"`
	// Amount of contextual padding to add around a window
	// (used only by the window_data_layer)
	ContextPad *uint32 `protobuf:"varint,10,opt,name=context_pad,def=0" json:"context_pad,omitempty"`
	// Mode for cropping out a detection window
	// warp: cropped window is warped to a fixed size and aspect ratio
	// square: the tightest square around the window is cropped
	CropMode *string `protobuf:"bytes,11,opt,name=crop_mode,def=warp" json:"crop_mode,omitempty"`
	// cache_images: will load all images in memory for faster access
	CacheImages *bool `protobuf:"varint,12,opt,name=cache_images,def=0" json:"cache_images,omitempty"`
	// append root_folder to locate images
	RootFolder       *string `protobuf:"bytes,13,opt,name=root_folder,def=" json:"root_folder,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *WindowDataParameter) Reset()                    { *m = WindowDataParameter{} }
func (m *WindowDataParameter) String() string            { return proto.CompactTextString(m) }
func (*WindowDataParameter) ProtoMessage()               {}
func (*WindowDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

const Default_WindowDataParameter_Scale float32 = 1
const Default_WindowDataParameter_CropSize uint32 = 0
const Default_WindowDataParameter_Mirror bool = false
const Default_WindowDataParameter_FgThreshold float32 = 0.5
const Default_WindowDataParameter_BgThreshold float32 = 0.5
const Default_WindowDataParameter_FgFraction float32 = 0.25
const Default_WindowDataParameter_ContextPad uint32 = 0
const Default_WindowDataParameter_CropMode string = "warp"
const Default_WindowDataParameter_CacheImages bool = false

func (m *WindowDataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *WindowDataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_WindowDataParameter_Scale
}

func (m *WindowDataParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *WindowDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *WindowDataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_WindowDataParameter_CropSize
}

func (m *WindowDataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_WindowDataParameter_Mirror
}

func (m *WindowDataParameter) GetFgThreshold() float32 {
	if m != nil && m.FgThreshold != nil {
		return *m.FgThreshold
	}
	return Default_WindowDataParameter_FgThreshold
}

func (m *WindowDataParameter) GetBgThreshold() float32 {
	if m != nil && m.BgThreshold != nil {
		return *m.BgThreshold
	}
	return Default_WindowDataParameter_BgThreshold
}

func (m *WindowDataParameter) GetFgFraction() float32 {
	if m != nil && m.FgFraction != nil {
		return *m.FgFraction
	}
	return Default_WindowDataParameter_FgFraction
}

func (m *WindowDataParameter) GetContextPad() uint32 {
	if m != nil && m.ContextPad != nil {
		return *m.ContextPad
	}
	return Default_WindowDataParameter_ContextPad
}

func (m *WindowDataParameter) GetCropMode() string {
	if m != nil && m.CropMode != nil {
		return *m.CropMode
	}
	return Default_WindowDataParameter_CropMode
}

func (m *WindowDataParameter) GetCacheImages() bool {
	if m != nil && m.CacheImages != nil {
		return *m.CacheImages
	}
	return Default_WindowDataParameter_CacheImages
}

func (m *WindowDataParameter) GetRootFolder() string {
	if m != nil && m.RootFolder != nil {
		return *m.RootFolder
	}
	return ""
}

// DEPRECATED: use LayerParameter.
type V1LayerParameter struct {
	Bottom               []string                        `protobuf:"bytes,2,rep,name=bottom" json:"bottom,omitempty"`
	Top                  []string                        `protobuf:"bytes,3,rep,name=top" json:"top,omitempty"`
	Name                 *string                         `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Include              []*NetStateRule                 `protobuf:"bytes,32,rep,name=include" json:"include,omitempty"`
	Exclude              []*NetStateRule                 `protobuf:"bytes,33,rep,name=exclude" json:"exclude,omitempty"`
	Type                 *V1LayerParameter_LayerType     `protobuf:"varint,5,opt,name=type,enum=caffe.V1LayerParameter_LayerType" json:"type,omitempty"`
	Blobs                []*BlobProto                    `protobuf:"bytes,6,rep,name=blobs" json:"blobs,omitempty"`
	Param                []string                        `protobuf:"bytes,1001,rep,name=param" json:"param,omitempty"`
	BlobShareMode        []V1LayerParameter_DimCheckMode `protobuf:"varint,1002,rep,name=blob_share_mode,enum=caffe.V1LayerParameter_DimCheckMode" json:"blob_share_mode,omitempty"`
	BlobsLr              []float32                       `protobuf:"fixed32,7,rep,name=blobs_lr" json:"blobs_lr,omitempty"`
	WeightDecay          []float32                       `protobuf:"fixed32,8,rep,name=weight_decay" json:"weight_decay,omitempty"`
	LossWeight           []float32                       `protobuf:"fixed32,35,rep,name=loss_weight" json:"loss_weight,omitempty"`
	AccuracyParam        *AccuracyParameter              `protobuf:"bytes,27,opt,name=accuracy_param" json:"accuracy_param,omitempty"`
	ArgmaxParam          *ArgMaxParameter                `protobuf:"bytes,23,opt,name=argmax_param" json:"argmax_param,omitempty"`
	ConcatParam          *ConcatParameter                `protobuf:"bytes,9,opt,name=concat_param" json:"concat_param,omitempty"`
	ContrastiveLossParam *ContrastiveLossParameter       `protobuf:"bytes,40,opt,name=contrastive_loss_param" json:"contrastive_loss_param,omitempty"`
	ConvolutionParam     *ConvolutionParameter           `protobuf:"bytes,10,opt,name=convolution_param" json:"convolution_param,omitempty"`
	DataParam            *DataParameter                  `protobuf:"bytes,11,opt,name=data_param" json:"data_param,omitempty"`
	DropoutParam         *DropoutParameter               `protobuf:"bytes,12,opt,name=dropout_param" json:"dropout_param,omitempty"`
	DummyDataParam       *DummyDataParameter             `protobuf:"bytes,26,opt,name=dummy_data_param" json:"dummy_data_param,omitempty"`
	EltwiseParam         *EltwiseParameter               `protobuf:"bytes,24,opt,name=eltwise_param" json:"eltwise_param,omitempty"`
	ExpParam             *ExpParameter                   `protobuf:"bytes,41,opt,name=exp_param" json:"exp_param,omitempty"`
	Hdf5DataParam        *HDF5DataParameter              `protobuf:"bytes,13,opt,name=hdf5_data_param" json:"hdf5_data_param,omitempty"`
	Hdf5OutputParam      *HDF5OutputParameter            `protobuf:"bytes,14,opt,name=hdf5_output_param" json:"hdf5_output_param,omitempty"`
	HingeLossParam       *HingeLossParameter             `protobuf:"bytes,29,opt,name=hinge_loss_param" json:"hinge_loss_param,omitempty"`
	ImageDataParam       *ImageDataParameter             `protobuf:"bytes,15,opt,name=image_data_param" json:"image_data_param,omitempty"`
	InfogainLossParam    *InfogainLossParameter          `protobuf:"bytes,16,opt,name=infogain_loss_param" json:"infogain_loss_param,omitempty"`
	InnerProductParam    *InnerProductParameter          `protobuf:"bytes,17,opt,name=inner_product_param" json:"inner_product_param,omitempty"`
	LrnParam             *LRNParameter                   `protobuf:"bytes,18,opt,name=lrn_param" json:"lrn_param,omitempty"`
	MemoryDataParam      *MemoryDataParameter            `protobuf:"bytes,22,opt,name=memory_data_param" json:"memory_data_param,omitempty"`
	MvnParam             *MVNParameter                   `protobuf:"bytes,34,opt,name=mvn_param" json:"mvn_param,omitempty"`
	PoolingParam         *PoolingParameter               `protobuf:"bytes,19,opt,name=pooling_param" json:"pooling_param,omitempty"`
	PowerParam           *PowerParameter                 `protobuf:"bytes,21,opt,name=power_param" json:"power_param,omitempty"`
	ReluParam            *ReLUParameter                  `protobuf:"bytes,30,opt,name=relu_param" json:"relu_param,omitempty"`
	SigmoidParam         *SigmoidParameter               `protobuf:"bytes,38,opt,name=sigmoid_param" json:"sigmoid_param,omitempty"`
	SoftmaxParam         *SoftmaxParameter               `protobuf:"bytes,39,opt,name=softmax_param" json:"softmax_param,omitempty"`
	SliceParam           *SliceParameter                 `protobuf:"bytes,31,opt,name=slice_param" json:"slice_param,omitempty"`
	TanhParam            *TanHParameter                  `protobuf:"bytes,37,opt,name=tanh_param" json:"tanh_param,omitempty"`
	ThresholdParam       *ThresholdParameter             `protobuf:"bytes,25,opt,name=threshold_param" json:"threshold_param,omitempty"`
	WindowDataParam      *WindowDataParameter            `protobuf:"bytes,20,opt,name=window_data_param" json:"window_data_param,omitempty"`
	TransformParam       *TransformationParameter        `protobuf:"bytes,36,opt,name=transform_param" json:"transform_param,omitempty"`
	LossParam            *LossParameter                  `protobuf:"bytes,42,opt,name=loss_param" json:"loss_param,omitempty"`
	Layer                *V0LayerParameter               `protobuf:"bytes,1,opt,name=layer" json:"layer,omitempty"`
	XXX_unrecognized     []byte                          `json:"-"`
}

func (m *V1LayerParameter) Reset()                    { *m = V1LayerParameter{} }
func (m *V1LayerParameter) String() string            { return proto.CompactTextString(m) }
func (*V1LayerParameter) ProtoMessage()               {}
func (*V1LayerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *V1LayerParameter) GetBottom() []string {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *V1LayerParameter) GetTop() []string {
	if m != nil {
		return m.Top
	}
	return nil
}

func (m *V1LayerParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *V1LayerParameter) GetInclude() []*NetStateRule {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *V1LayerParameter) GetExclude() []*NetStateRule {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *V1LayerParameter) GetType() V1LayerParameter_LayerType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return V1LayerParameter_NONE
}

func (m *V1LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *V1LayerParameter) GetParam() []string {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *V1LayerParameter) GetBlobShareMode() []V1LayerParameter_DimCheckMode {
	if m != nil {
		return m.BlobShareMode
	}
	return nil
}

func (m *V1LayerParameter) GetBlobsLr() []float32 {
	if m != nil {
		return m.BlobsLr
	}
	return nil
}

func (m *V1LayerParameter) GetWeightDecay() []float32 {
	if m != nil {
		return m.WeightDecay
	}
	return nil
}

func (m *V1LayerParameter) GetLossWeight() []float32 {
	if m != nil {
		return m.LossWeight
	}
	return nil
}

func (m *V1LayerParameter) GetAccuracyParam() *AccuracyParameter {
	if m != nil {
		return m.AccuracyParam
	}
	return nil
}

func (m *V1LayerParameter) GetArgmaxParam() *ArgMaxParameter {
	if m != nil {
		return m.ArgmaxParam
	}
	return nil
}

func (m *V1LayerParameter) GetConcatParam() *ConcatParameter {
	if m != nil {
		return m.ConcatParam
	}
	return nil
}

func (m *V1LayerParameter) GetContrastiveLossParam() *ContrastiveLossParameter {
	if m != nil {
		return m.ContrastiveLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetConvolutionParam() *ConvolutionParameter {
	if m != nil {
		return m.ConvolutionParam
	}
	return nil
}

func (m *V1LayerParameter) GetDataParam() *DataParameter {
	if m != nil {
		return m.DataParam
	}
	return nil
}

func (m *V1LayerParameter) GetDropoutParam() *DropoutParameter {
	if m != nil {
		return m.DropoutParam
	}
	return nil
}

func (m *V1LayerParameter) GetDummyDataParam() *DummyDataParameter {
	if m != nil {
		return m.DummyDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetEltwiseParam() *EltwiseParameter {
	if m != nil {
		return m.EltwiseParam
	}
	return nil
}

func (m *V1LayerParameter) GetExpParam() *ExpParameter {
	if m != nil {
		return m.ExpParam
	}
	return nil
}

func (m *V1LayerParameter) GetHdf5DataParam() *HDF5DataParameter {
	if m != nil {
		return m.Hdf5DataParam
	}
	return nil
}

func (m *V1LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

func (m *V1LayerParameter) GetHingeLossParam() *HingeLossParameter {
	if m != nil {
		return m.HingeLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetImageDataParam() *ImageDataParameter {
	if m != nil {
		return m.ImageDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetInfogainLossParam() *InfogainLossParameter {
	if m != nil {
		return m.InfogainLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetInnerProductParam() *InnerProductParameter {
	if m != nil {
		return m.InnerProductParam
	}
	return nil
}

func (m *V1LayerParameter) GetLrnParam() *LRNParameter {
	if m != nil {
		return m.LrnParam
	}
	return nil
}

func (m *V1LayerParameter) GetMemoryDataParam() *MemoryDataParameter {
	if m != nil {
		return m.MemoryDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetMvnParam() *MVNParameter {
	if m != nil {
		return m.MvnParam
	}
	return nil
}

func (m *V1LayerParameter) GetPoolingParam() *PoolingParameter {
	if m != nil {
		return m.PoolingParam
	}
	return nil
}

func (m *V1LayerParameter) GetPowerParam() *PowerParameter {
	if m != nil {
		return m.PowerParam
	}
	return nil
}

func (m *V1LayerParameter) GetReluParam() *ReLUParameter {
	if m != nil {
		return m.ReluParam
	}
	return nil
}

func (m *V1LayerParameter) GetSigmoidParam() *SigmoidParameter {
	if m != nil {
		return m.SigmoidParam
	}
	return nil
}

func (m *V1LayerParameter) GetSoftmaxParam() *SoftmaxParameter {
	if m != nil {
		return m.SoftmaxParam
	}
	return nil
}

func (m *V1LayerParameter) GetSliceParam() *SliceParameter {
	if m != nil {
		return m.SliceParam
	}
	return nil
}

func (m *V1LayerParameter) GetTanhParam() *TanHParameter {
	if m != nil {
		return m.TanhParam
	}
	return nil
}

func (m *V1LayerParameter) GetThresholdParam() *ThresholdParameter {
	if m != nil {
		return m.ThresholdParam
	}
	return nil
}

func (m *V1LayerParameter) GetWindowDataParam() *WindowDataParameter {
	if m != nil {
		return m.WindowDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetTransformParam() *TransformationParameter {
	if m != nil {
		return m.TransformParam
	}
	return nil
}

func (m *V1LayerParameter) GetLossParam() *LossParameter {
	if m != nil {
		return m.LossParam
	}
	return nil
}

func (m *V1LayerParameter) GetLayer() *V0LayerParameter {
	if m != nil {
		return m.Layer
	}
	return nil
}

// DEPRECATED: V0LayerParameter is the old way of specifying layer parameters
// in Caffe.  We keep this message type around for legacy support.
type V0LayerParameter struct {
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type *string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// Parameters to specify layers with inner products.
	NumOutput    *uint32                      `protobuf:"varint,3,opt,name=num_output" json:"num_output,omitempty"`
	Biasterm     *bool                        `protobuf:"varint,4,opt,name=biasterm,def=1" json:"biasterm,omitempty"`
	WeightFiller *FillerParameter             `protobuf:"bytes,5,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter             `protobuf:"bytes,6,opt,name=bias_filler" json:"bias_filler,omitempty"`
	Pad          *uint32                      `protobuf:"varint,7,opt,name=pad,def=0" json:"pad,omitempty"`
	Kernelsize   *uint32                      `protobuf:"varint,8,opt,name=kernelsize" json:"kernelsize,omitempty"`
	Group        *uint32                      `protobuf:"varint,9,opt,name=group,def=1" json:"group,omitempty"`
	Stride       *uint32                      `protobuf:"varint,10,opt,name=stride,def=1" json:"stride,omitempty"`
	Pool         *V0LayerParameter_PoolMethod `protobuf:"varint,11,opt,name=pool,enum=caffe.V0LayerParameter_PoolMethod,def=0" json:"pool,omitempty"`
	DropoutRatio *float32                     `protobuf:"fixed32,12,opt,name=dropout_ratio,def=0.5" json:"dropout_ratio,omitempty"`
	LocalSize    *uint32                      `protobuf:"varint,13,opt,name=local_size,def=5" json:"local_size,omitempty"`
	Alpha        *float32                     `protobuf:"fixed32,14,opt,name=alpha,def=1" json:"alpha,omitempty"`
	Beta         *float32                     `protobuf:"fixed32,15,opt,name=beta,def=0.75" json:"beta,omitempty"`
	K            *float32                     `protobuf:"fixed32,22,opt,name=k,def=1" json:"k,omitempty"`
	// For data layers, specify the data source
	Source *string `protobuf:"bytes,16,opt,name=source" json:"source,omitempty"`
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale    *float32 `protobuf:"fixed32,17,opt,name=scale,def=1" json:"scale,omitempty"`
	Meanfile *string  `protobuf:"bytes,18,opt,name=meanfile" json:"meanfile,omitempty"`
	// For data layers, specify the batch size.
	Batchsize *uint32 `protobuf:"varint,19,opt,name=batchsize" json:"batchsize,omitempty"`
	// For data layers, specify if we would like to randomly crop an image.
	Cropsize *uint32 `protobuf:"varint,20,opt,name=cropsize,def=0" json:"cropsize,omitempty"`
	// For data layers, specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,21,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// The blobs containing the numeric parameters of the layer
	Blobs []*BlobProto `protobuf:"bytes,50,rep,name=blobs" json:"blobs,omitempty"`
	// The ratio that is multiplied on the global learning rate. If you want to
	// set the learning ratio for one blob, you need to set it for all blobs.
	BlobsLr []float32 `protobuf:"fixed32,51,rep,name=blobs_lr" json:"blobs_lr,omitempty"`
	// The weight decay that is multiplied on the global weight decay.
	WeightDecay []float32 `protobuf:"fixed32,52,rep,name=weight_decay" json:"weight_decay,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32 `protobuf:"varint,53,opt,name=rand_skip,def=0" json:"rand_skip,omitempty"`
	// Fields related to detection (det_*)
	// foreground (object) overlap threshold
	DetFgThreshold *float32 `protobuf:"fixed32,54,opt,name=det_fg_threshold,def=0.5" json:"det_fg_threshold,omitempty"`
	// background (non-object) overlap threshold
	DetBgThreshold *float32 `protobuf:"fixed32,55,opt,name=det_bg_threshold,def=0.5" json:"det_bg_threshold,omitempty"`
	// Fraction of batch that should be foreground objects
	DetFgFraction *float32 `protobuf:"fixed32,56,opt,name=det_fg_fraction,def=0.25" json:"det_fg_fraction,omitempty"`
	// Amount of contextual padding to add around a window
	// (used only by the window_data_layer)
	DetContextPad *uint32 `protobuf:"varint,58,opt,name=det_context_pad,def=0" json:"det_context_pad,omitempty"`
	// Mode for cropping out a detection window
	// warp: cropped window is warped to a fixed size and aspect ratio
	// square: the tightest square around the window is cropped
	DetCropMode *string `protobuf:"bytes,59,opt,name=det_crop_mode,def=warp" json:"det_crop_mode,omitempty"`
	// For ReshapeLayer, one needs to specify the new dimensions.
	NewNum      *int32 `protobuf:"varint,60,opt,name=new_num,def=0" json:"new_num,omitempty"`
	NewChannels *int32 `protobuf:"varint,61,opt,name=new_channels,def=0" json:"new_channels,omitempty"`
	NewHeight   *int32 `protobuf:"varint,62,opt,name=new_height,def=0" json:"new_height,omitempty"`
	NewWidth    *int32 `protobuf:"varint,63,opt,name=new_width,def=0" json:"new_width,omitempty"`
	// Whether or not ImageLayer should shuffle the list of files at every epoch.
	// It will also resize images if new_height or new_width are not zero.
	ShuffleImages *bool `protobuf:"varint,64,opt,name=shuffle_images,def=0" json:"shuffle_images,omitempty"`
	// For ConcatLayer, one needs to specify the dimension for concatenation, and
	// the other dimensions must be the same for all the bottom blobs.
	// By default it will concatenate blobs along the channels dimension.
	ConcatDim        *uint32              `protobuf:"varint,65,opt,name=concat_dim,def=1" json:"concat_dim,omitempty"`
	Hdf5OutputParam  *HDF5OutputParameter `protobuf:"bytes,1001,opt,name=hdf5_output_param" json:"hdf5_output_param,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *V0LayerParameter) Reset()                    { *m = V0LayerParameter{} }
func (m *V0LayerParameter) String() string            { return proto.CompactTextString(m) }
func (*V0LayerParameter) ProtoMessage()               {}
func (*V0LayerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

const Default_V0LayerParameter_Biasterm bool = true
const Default_V0LayerParameter_Pad uint32 = 0
const Default_V0LayerParameter_Group uint32 = 1
const Default_V0LayerParameter_Stride uint32 = 1
const Default_V0LayerParameter_Pool V0LayerParameter_PoolMethod = V0LayerParameter_MAX
const Default_V0LayerParameter_DropoutRatio float32 = 0.5
const Default_V0LayerParameter_LocalSize uint32 = 5
const Default_V0LayerParameter_Alpha float32 = 1
const Default_V0LayerParameter_Beta float32 = 0.75
const Default_V0LayerParameter_K float32 = 1
const Default_V0LayerParameter_Scale float32 = 1
const Default_V0LayerParameter_Cropsize uint32 = 0
const Default_V0LayerParameter_Mirror bool = false
const Default_V0LayerParameter_RandSkip uint32 = 0
const Default_V0LayerParameter_DetFgThreshold float32 = 0.5
const Default_V0LayerParameter_DetBgThreshold float32 = 0.5
const Default_V0LayerParameter_DetFgFraction float32 = 0.25
const Default_V0LayerParameter_DetContextPad uint32 = 0
const Default_V0LayerParameter_DetCropMode string = "warp"
const Default_V0LayerParameter_NewNum int32 = 0
const Default_V0LayerParameter_NewChannels int32 = 0
const Default_V0LayerParameter_NewHeight int32 = 0
const Default_V0LayerParameter_NewWidth int32 = 0
const Default_V0LayerParameter_ShuffleImages bool = false
const Default_V0LayerParameter_ConcatDim uint32 = 1

func (m *V0LayerParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *V0LayerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *V0LayerParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *V0LayerParameter) GetBiasterm() bool {
	if m != nil && m.Biasterm != nil {
		return *m.Biasterm
	}
	return Default_V0LayerParameter_Biasterm
}

func (m *V0LayerParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *V0LayerParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *V0LayerParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_V0LayerParameter_Pad
}

func (m *V0LayerParameter) GetKernelsize() uint32 {
	if m != nil && m.Kernelsize != nil {
		return *m.Kernelsize
	}
	return 0
}

func (m *V0LayerParameter) GetGroup() uint32 {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Default_V0LayerParameter_Group
}

func (m *V0LayerParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_V0LayerParameter_Stride
}

func (m *V0LayerParameter) GetPool() V0LayerParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_V0LayerParameter_Pool
}

func (m *V0LayerParameter) GetDropoutRatio() float32 {
	if m != nil && m.DropoutRatio != nil {
		return *m.DropoutRatio
	}
	return Default_V0LayerParameter_DropoutRatio
}

func (m *V0LayerParameter) GetLocalSize() uint32 {
	if m != nil && m.LocalSize != nil {
		return *m.LocalSize
	}
	return Default_V0LayerParameter_LocalSize
}

func (m *V0LayerParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_V0LayerParameter_Alpha
}

func (m *V0LayerParameter) GetBeta() float32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return Default_V0LayerParameter_Beta
}

func (m *V0LayerParameter) GetK() float32 {
	if m != nil && m.K != nil {
		return *m.K
	}
	return Default_V0LayerParameter_K
}

func (m *V0LayerParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *V0LayerParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_V0LayerParameter_Scale
}

func (m *V0LayerParameter) GetMeanfile() string {
	if m != nil && m.Meanfile != nil {
		return *m.Meanfile
	}
	return ""
}

func (m *V0LayerParameter) GetBatchsize() uint32 {
	if m != nil && m.Batchsize != nil {
		return *m.Batchsize
	}
	return 0
}

func (m *V0LayerParameter) GetCropsize() uint32 {
	if m != nil && m.Cropsize != nil {
		return *m.Cropsize
	}
	return Default_V0LayerParameter_Cropsize
}

func (m *V0LayerParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_V0LayerParameter_Mirror
}

func (m *V0LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *V0LayerParameter) GetBlobsLr() []float32 {
	if m != nil {
		return m.BlobsLr
	}
	return nil
}

func (m *V0LayerParameter) GetWeightDecay() []float32 {
	if m != nil {
		return m.WeightDecay
	}
	return nil
}

func (m *V0LayerParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_V0LayerParameter_RandSkip
}

func (m *V0LayerParameter) GetDetFgThreshold() float32 {
	if m != nil && m.DetFgThreshold != nil {
		return *m.DetFgThreshold
	}
	return Default_V0LayerParameter_DetFgThreshold
}

func (m *V0LayerParameter) GetDetBgThreshold() float32 {
	if m != nil && m.DetBgThreshold != nil {
		return *m.DetBgThreshold
	}
	return Default_V0LayerParameter_DetBgThreshold
}

func (m *V0LayerParameter) GetDetFgFraction() float32 {
	if m != nil && m.DetFgFraction != nil {
		return *m.DetFgFraction
	}
	return Default_V0LayerParameter_DetFgFraction
}

func (m *V0LayerParameter) GetDetContextPad() uint32 {
	if m != nil && m.DetContextPad != nil {
		return *m.DetContextPad
	}
	return Default_V0LayerParameter_DetContextPad
}

func (m *V0LayerParameter) GetDetCropMode() string {
	if m != nil && m.DetCropMode != nil {
		return *m.DetCropMode
	}
	return Default_V0LayerParameter_DetCropMode
}

func (m *V0LayerParameter) GetNewNum() int32 {
	if m != nil && m.NewNum != nil {
		return *m.NewNum
	}
	return Default_V0LayerParameter_NewNum
}

func (m *V0LayerParameter) GetNewChannels() int32 {
	if m != nil && m.NewChannels != nil {
		return *m.NewChannels
	}
	return Default_V0LayerParameter_NewChannels
}

func (m *V0LayerParameter) GetNewHeight() int32 {
	if m != nil && m.NewHeight != nil {
		return *m.NewHeight
	}
	return Default_V0LayerParameter_NewHeight
}

func (m *V0LayerParameter) GetNewWidth() int32 {
	if m != nil && m.NewWidth != nil {
		return *m.NewWidth
	}
	return Default_V0LayerParameter_NewWidth
}

func (m *V0LayerParameter) GetShuffleImages() bool {
	if m != nil && m.ShuffleImages != nil {
		return *m.ShuffleImages
	}
	return Default_V0LayerParameter_ShuffleImages
}

func (m *V0LayerParameter) GetConcatDim() uint32 {
	if m != nil && m.ConcatDim != nil {
		return *m.ConcatDim
	}
	return Default_V0LayerParameter_ConcatDim
}

func (m *V0LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

// Message that stores parameters used by PReLULayer
type PReLUParameter struct {
	// Initial value of a_i. Default is a_i=0.25 for all i.
	Filler *FillerParameter `protobuf:"bytes,1,opt,name=filler" json:"filler,omitempty"`
	// Whether or not slope paramters are shared across channels.
	ChannelShared    *bool  `protobuf:"varint,2,opt,name=channel_shared,def=0" json:"channel_shared,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PReLUParameter) Reset()                    { *m = PReLUParameter{} }
func (m *PReLUParameter) String() string            { return proto.CompactTextString(m) }
func (*PReLUParameter) ProtoMessage()               {}
func (*PReLUParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

const Default_PReLUParameter_ChannelShared bool = false

func (m *PReLUParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

func (m *PReLUParameter) GetChannelShared() bool {
	if m != nil && m.ChannelShared != nil {
		return *m.ChannelShared
	}
	return Default_PReLUParameter_ChannelShared
}

func init() {
	proto.RegisterType((*BlobShape)(nil), "caffe.BlobShape")
	proto.RegisterType((*BlobProto)(nil), "caffe.BlobProto")
	proto.RegisterType((*BlobProtoVector)(nil), "caffe.BlobProtoVector")
	proto.RegisterType((*Datum)(nil), "caffe.Datum")
	proto.RegisterType((*FillerParameter)(nil), "caffe.FillerParameter")
	proto.RegisterType((*NetParameter)(nil), "caffe.NetParameter")
	proto.RegisterType((*SolverParameter)(nil), "caffe.SolverParameter")
	proto.RegisterType((*SolverState)(nil), "caffe.SolverState")
	proto.RegisterType((*NetState)(nil), "caffe.NetState")
	proto.RegisterType((*NetStateRule)(nil), "caffe.NetStateRule")
	proto.RegisterType((*ParamSpec)(nil), "caffe.ParamSpec")
	proto.RegisterType((*LayerParameter)(nil), "caffe.LayerParameter")
	proto.RegisterType((*TransformationParameter)(nil), "caffe.TransformationParameter")
	proto.RegisterType((*LossParameter)(nil), "caffe.LossParameter")
	proto.RegisterType((*AccuracyParameter)(nil), "caffe.AccuracyParameter")
	proto.RegisterType((*ArgMaxParameter)(nil), "caffe.ArgMaxParameter")
	proto.RegisterType((*ConcatParameter)(nil), "caffe.ConcatParameter")
	proto.RegisterType((*ContrastiveLossParameter)(nil), "caffe.ContrastiveLossParameter")
	proto.RegisterType((*ConvolutionParameter)(nil), "caffe.ConvolutionParameter")
	proto.RegisterType((*DataParameter)(nil), "caffe.DataParameter")
	proto.RegisterType((*DropoutParameter)(nil), "caffe.DropoutParameter")
	proto.RegisterType((*DummyDataParameter)(nil), "caffe.DummyDataParameter")
	proto.RegisterType((*EltwiseParameter)(nil), "caffe.EltwiseParameter")
	proto.RegisterType((*ExpParameter)(nil), "caffe.ExpParameter")
	proto.RegisterType((*HDF5DataParameter)(nil), "caffe.HDF5DataParameter")
	proto.RegisterType((*HDF5OutputParameter)(nil), "caffe.HDF5OutputParameter")
	proto.RegisterType((*HingeLossParameter)(nil), "caffe.HingeLossParameter")
	proto.RegisterType((*ImageDataParameter)(nil), "caffe.ImageDataParameter")
	proto.RegisterType((*InfogainLossParameter)(nil), "caffe.InfogainLossParameter")
	proto.RegisterType((*InnerProductParameter)(nil), "caffe.InnerProductParameter")
	proto.RegisterType((*LRNParameter)(nil), "caffe.LRNParameter")
	proto.RegisterType((*MemoryDataParameter)(nil), "caffe.MemoryDataParameter")
	proto.RegisterType((*MVNParameter)(nil), "caffe.MVNParameter")
	proto.RegisterType((*PoolingParameter)(nil), "caffe.PoolingParameter")
	proto.RegisterType((*PowerParameter)(nil), "caffe.PowerParameter")
	proto.RegisterType((*PythonParameter)(nil), "caffe.PythonParameter")
	proto.RegisterType((*ReLUParameter)(nil), "caffe.ReLUParameter")
	proto.RegisterType((*SigmoidParameter)(nil), "caffe.SigmoidParameter")
	proto.RegisterType((*SliceParameter)(nil), "caffe.SliceParameter")
	proto.RegisterType((*SoftmaxParameter)(nil), "caffe.SoftmaxParameter")
	proto.RegisterType((*TanHParameter)(nil), "caffe.TanHParameter")
	proto.RegisterType((*ThresholdParameter)(nil), "caffe.ThresholdParameter")
	proto.RegisterType((*WindowDataParameter)(nil), "caffe.WindowDataParameter")
	proto.RegisterType((*V1LayerParameter)(nil), "caffe.V1LayerParameter")
	proto.RegisterType((*V0LayerParameter)(nil), "caffe.V0LayerParameter")
	proto.RegisterType((*PReLUParameter)(nil), "caffe.PReLUParameter")
	proto.RegisterEnum("caffe.Phase", Phase_name, Phase_value)
	proto.RegisterEnum("caffe.SolverParameter_SolverMode", SolverParameter_SolverMode_name, SolverParameter_SolverMode_value)
	proto.RegisterEnum("caffe.SolverParameter_SolverType", SolverParameter_SolverType_name, SolverParameter_SolverType_value)
	proto.RegisterEnum("caffe.ParamSpec_DimCheckMode", ParamSpec_DimCheckMode_name, ParamSpec_DimCheckMode_value)
	proto.RegisterEnum("caffe.ConvolutionParameter_Engine", ConvolutionParameter_Engine_name, ConvolutionParameter_Engine_value)
	proto.RegisterEnum("caffe.DataParameter_DB", DataParameter_DB_name, DataParameter_DB_value)
	proto.RegisterEnum("caffe.EltwiseParameter_EltwiseOp", EltwiseParameter_EltwiseOp_name, EltwiseParameter_EltwiseOp_value)
	proto.RegisterEnum("caffe.HingeLossParameter_Norm", HingeLossParameter_Norm_name, HingeLossParameter_Norm_value)
	proto.RegisterEnum("caffe.LRNParameter_NormRegion", LRNParameter_NormRegion_name, LRNParameter_NormRegion_value)
	proto.RegisterEnum("caffe.PoolingParameter_PoolMethod", PoolingParameter_PoolMethod_name, PoolingParameter_PoolMethod_value)
	proto.RegisterEnum("caffe.PoolingParameter_Engine", PoolingParameter_Engine_name, PoolingParameter_Engine_value)
	proto.RegisterEnum("caffe.ReLUParameter_Engine", ReLUParameter_Engine_name, ReLUParameter_Engine_value)
	proto.RegisterEnum("caffe.SigmoidParameter_Engine", SigmoidParameter_Engine_name, SigmoidParameter_Engine_value)
	proto.RegisterEnum("caffe.SoftmaxParameter_Engine", SoftmaxParameter_Engine_name, SoftmaxParameter_Engine_value)
	proto.RegisterEnum("caffe.TanHParameter_Engine", TanHParameter_Engine_name, TanHParameter_Engine_value)
	proto.RegisterEnum("caffe.V1LayerParameter_LayerType", V1LayerParameter_LayerType_name, V1LayerParameter_LayerType_value)
	proto.RegisterEnum("caffe.V1LayerParameter_DimCheckMode", V1LayerParameter_DimCheckMode_name, V1LayerParameter_DimCheckMode_value)
	proto.RegisterEnum("caffe.V0LayerParameter_PoolMethod", V0LayerParameter_PoolMethod_name, V0LayerParameter_PoolMethod_value)
}

func init() { proto.RegisterFile("caffe.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 4163 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x5a, 0x4b, 0x73, 0x1b, 0x49,
	0x72, 0x5e, 0xbc, 0x08, 0xa0, 0xf0, 0x6a, 0x36, 0x49, 0x09, 0x22, 0x25, 0x4a, 0xea, 0xd1, 0xcc,
	0xc8, 0x9a, 0x1d, 0x9a, 0xe4, 0x0e, 0x67, 0x76, 0x38, 0xf6, 0x8c, 0x21, 0x00, 0x94, 0x10, 0x81,
	0x57, 0x00, 0x20, 0xb5, 0xe3, 0x83, 0x3b, 0x9a, 0x40, 0x03, 0x68, 0xab, 0x81, 0x86, 0xbb, 0x1b,
	0x22, 0x35, 0x7e, 0xac, 0xd7, 0x3e, 0xf9, 0xe0, 0xc7, 0xc1, 0x27, 0x9f, 0x1c, 0x76, 0x38, 0x7c,
	0xb5, 0x7f, 0x81, 0xc3, 0x7f, 0xc2, 0xe1, 0xa3, 0xaf, 0xeb, 0xff, 0xe0, 0x08, 0x67, 0x65, 0x55,
	0x3f, 0x0a, 0x00, 0x39, 0x82, 0xb4, 0x27, 0xb2, 0xab, 0xb2, 0xaa, 0xb2, 0xb2, 0xb2, 0x32, 0xbf,
	0xfc, 0x0a, 0x24, 0xd3, 0xd7, 0x86, 0x43, 0xfd, 0x60, 0x66, 0x5b, 0xae, 0x25, 0x27, 0xf0, 0x43,
	0xb9, 0x4f, 0xd2, 0xcf, 0x4d, 0xeb, 0xb2, 0x3b, 0xd6, 0x66, 0xba, 0x5c, 0x20, 0xb1, 0x81, 0x31,
	0x29, 0x46, 0x1e, 0xc5, 0x9e, 0xc6, 0x9e, 0x47, 0xa5, 0x88, 0xf2, 0x0f, 0x11, 0xd6, 0xdd, 0xc6,
	0x21, 0x0f, 0x49, 0xc2, 0xa1, 0x72, 0xc5, 0xe4, 0xa3, 0xc8, 0xd3, 0xcc, 0xb1, 0x74, 0xc0, 0xe6,
	0x0b, 0xc6, 0x4b, 0x24, 0x3e, 0xd0, 0x5c, 0xad, 0x98, 0x80, 0x09, 0xa2, 0x74, 0x02, 0x6c, 0x31,
	0x86, 0xc3, 0xe2, 0x86, 0xdf, 0x92, 0x27, 0xb1, 0xe9, 0x9c, 0xae, 0x11, 0x79, 0x9a, 0x38, 0x8d,
	0x1c, 0xca, 0x5b, 0x24, 0xd5, 0x1f, 0x6b, 0xd3, 0xa9, 0x6e, 0x3a, 0xc5, 0xa8, 0xd7, 0xb8, 0x49,
	0x36, 0xc6, 0xba, 0x31, 0x1a, 0xbb, 0xc5, 0x98, 0xd7, 0x24, 0x91, 0xc4, 0x95, 0x31, 0x70, 0xc7,
	0xc5, 0x38, 0x6f, 0x51, 0x8e, 0x49, 0xc1, 0xd7, 0xed, 0x42, 0xef, 0xbb, 0x96, 0x4d, 0x35, 0xbc,
	0x84, 0x26, 0x07, 0xb7, 0x20, 0x6a, 0x88, 0x62, 0xca, 0xaf, 0x22, 0x24, 0x51, 0xd1, 0xdc, 0xf9,
	0x04, 0xe6, 0x0b, 0xd6, 0x45, 0x65, 0x40, 0x33, 0x6f, 0x51, 0xd4, 0x43, 0xce, 0x79, 0x2b, 0xa2,
	0x0e, 0x72, 0x96, 0x6f, 0x8e, 0xae, 0x9f, 0xa5, 0x9d, 0xa6, 0x76, 0xa9, 0x9b, 0xb0, 0x57, 0xda,
	0x29, 0x13, 0x32, 0x34, 0x2d, 0xcd, 0x55, 0x51, 0x04, 0x77, 0x2b, 0xdf, 0x21, 0x49, 0x7d, 0xda,
	0xb7, 0x06, 0xfa, 0x00, 0x0d, 0x96, 0x3a, 0x4d, 0x0c, 0x35, 0xd3, 0xd1, 0x95, 0xbf, 0x8b, 0x90,
	0xc2, 0x99, 0x61, 0x9a, 0xba, 0xdd, 0xd6, 0x6c, 0x6d, 0xa2, 0xbb, 0xba, 0x0d, 0xb2, 0x71, 0xf7,
	0x2d, 0x58, 0x96, 0x6a, 0x92, 0x3e, 0x4d, 0xf5, 0xad, 0xa9, 0xe3, 0x6a, 0x53, 0x97, 0xee, 0xfa,
	0x8d, 0x66, 0xce, 0x75, 0x54, 0x29, 0x4a, 0xed, 0x00, 0xf6, 0x9b, 0x18, 0x53, 0xd4, 0xc9, 0xff,
	0xd6, 0xae, 0x51, 0x2b, 0xf8, 0x3e, 0x82, 0x33, 0x8c, 0x4f, 0x74, 0x6d, 0x8a, 0x7a, 0x79, 0x02,
	0x8e, 0x3b, 0x00, 0x9d, 0xb8, 0x80, 0x4c, 0x36, 0x9c, 0x99, 0x66, 0x3b, 0xec, 0x18, 0x13, 0xa7,
	0xd1, 0xcf, 0x8f, 0x94, 0xbf, 0x89, 0x92, 0x6c, 0x53, 0x77, 0x03, 0x7d, 0x60, 0xb3, 0x53, 0xf8,
	0x97, 0xe9, 0x43, 0x37, 0x6b, 0x4c, 0x67, 0x73, 0x7a, 0x1a, 0x31, 0xf8, 0xfc, 0x98, 0x64, 0xf0,
	0x53, 0x65, 0xde, 0x90, 0x5a, 0xb2, 0x35, 0xf3, 0x86, 0x4d, 0x92, 0x66, 0x62, 0xd4, 0xa7, 0xe2,
	0x20, 0x94, 0x90, 0x1f, 0x90, 0xfc, 0xd0, 0xb2, 0xfb, 0xba, 0x7a, 0xa9, 0xf5, 0x5f, 0x5f, 0x69,
	0xf6, 0x00, 0xd5, 0xf4, 0x2c, 0x23, 0xef, 0x83, 0x83, 0xb9, 0x9a, 0xab, 0xa3, 0xb2, 0x99, 0xe3,
	0x02, 0x9f, 0x12, 0x34, 0xeb, 0xd2, 0x66, 0xf9, 0x1e, 0x21, 0x03, 0xfd, 0x72, 0x3e, 0x52, 0x8d,
	0xe9, 0xd0, 0x12, 0x8c, 0x2a, 0x3f, 0xa1, 0xe7, 0xf1, 0x56, 0xb7, 0x8b, 0x03, 0xd4, 0x66, 0x87,
	0x0f, 0xad, 0xd3, 0xb6, 0x60, 0x5b, 0x9f, 0x92, 0x0d, 0x94, 0xa2, 0xae, 0x46, 0xc5, 0xee, 0x72,
	0xb1, 0x8b, 0x23, 0x51, 0x50, 0xf9, 0xd7, 0x14, 0x29, 0x74, 0x2d, 0xf3, 0x4d, 0x78, 0x70, 0x06,
	0x3c, 0x57, 0x77, 0x8b, 0x45, 0x34, 0xc9, 0x27, 0x24, 0x0d, 0x1f, 0xea, 0x8c, 0xf6, 0x16, 0xef,
	0xa1, 0xba, 0x5b, 0x81, 0xba, 0xc1, 0x20, 0x30, 0x82, 0x6b, 0x6b, 0xc6, 0x54, 0xa5, 0x43, 0x99,
	0x35, 0xc1, 0xf3, 0x5c, 0xdd, 0x71, 0xb1, 0x25, 0x8a, 0x06, 0xfd, 0x29, 0x29, 0xf8, 0x42, 0x7c,
	0xca, 0x9d, 0x9b, 0xa7, 0xfc, 0x8c, 0xe4, 0xbd, 0xf1, 0x5c, 0xf8, 0x0e, 0x6e, 0x66, 0xa5, 0xf0,
	0x13, 0x92, 0x61, 0x53, 0x33, 0xc3, 0xee, 0xae, 0x36, 0xec, 0x47, 0x84, 0xe0, 0x94, 0x4c, 0x68,
	0x0f, 0xa7, 0x5b, 0x12, 0xa2, 0x5b, 0xa1, 0x42, 0x06, 0xcc, 0x8b, 0x9e, 0x90, 0x90, 0x8b, 0x24,
	0xc7, 0x9a, 0xa6, 0xd0, 0x06, 0x8e, 0xea, 0x5f, 0x4e, 0xf9, 0x11, 0xd9, 0xc4, 0x9e, 0xbe, 0x35,
	0x01, 0x17, 0xd0, 0x55, 0xd3, 0x72, 0x9c, 0xe2, 0x56, 0xf8, 0xc4, 0x1e, 0x93, 0x2d, 0x3e, 0xd6,
	0x70, 0x0d, 0xcd, 0x34, 0x7e, 0xd0, 0x5c, 0xc3, 0x9a, 0x16, 0x1f, 0xa1, 0x4c, 0xdc, 0xb5, 0xe7,
	0x34, 0x1e, 0x25, 0x2f, 0x35, 0x07, 0x06, 0xdb, 0xcc, 0x9d, 0x69, 0xc3, 0xc0, 0x70, 0x66, 0x70,
	0x86, 0xe8, 0x22, 0x09, 0xf9, 0x2e, 0xc9, 0x6a, 0x70, 0x48, 0xda, 0x88, 0xaf, 0xf0, 0x98, 0xad,
	0x7f, 0x44, 0x8d, 0x0c, 0xd7, 0x82, 0xe9, 0x8a, 0x7e, 0x4e, 0xd5, 0x37, 0x6d, 0x75, 0x66, 0x99,
	0x46, 0xff, 0x2d, 0xf8, 0x2c, 0xf7, 0xeb, 0x91, 0x36, 0x99, 0x68, 0xc5, 0x34, 0xce, 0x0e, 0x9f,
	0x33, 0xeb, 0x0a, 0x06, 0x10, 0xfc, 0xa4, 0x53, 0x58, 0x13, 0x7d, 0x0a, 0xd1, 0xa2, 0x98, 0xc1,
	0x96, 0x6d, 0x92, 0xbd, 0xc2, 0x08, 0xa1, 0x0e, 0xf4, 0x3e, 0xe8, 0x90, 0xc5, 0xd6, 0x87, 0x64,
	0xcb, 0xd6, 0x47, 0x73, 0x53, 0xb3, 0xf9, 0x1e, 0x54, 0xbc, 0xca, 0x0f, 0xf0, 0x2a, 0x47, 0xeb,
	0xc7, 0x74, 0x22, 0xc7, 0xd5, 0x67, 0x8e, 0xf1, 0x83, 0x5e, 0xcc, 0x79, 0xba, 0xd0, 0x16, 0x76,
	0xb5, 0x15, 0x34, 0xe5, 0x2e, 0xc9, 0xf7, 0x4d, 0x63, 0xa6, 0x8e, 0x6c, 0x6d, 0x60, 0xc0, 0xa2,
	0x4e, 0xf1, 0x23, 0xbc, 0xb1, 0x70, 0x3d, 0x69, 0x8c, 0x74, 0xa6, 0xda, 0xcc, 0x19, 0x5b, 0x6e,
	0x31, 0xef, 0x59, 0xf8, 0x2e, 0x29, 0x78, 0x8d, 0xea, 0xcc, 0xd6, 0x87, 0xc6, 0x75, 0xb1, 0x80,
	0xbb, 0xba, 0x4f, 0x72, 0x7e, 0x07, 0x06, 0x5f, 0x29, 0x6c, 0xf6, 0x6f, 0x48, 0xc6, 0x41, 0xc7,
	0x56, 0x27, 0x10, 0x9a, 0x8a, 0x9b, 0xd0, 0x97, 0x3f, 0x7e, 0xcc, 0xcf, 0x7a, 0xc1, 0xe5, 0xf9,
	0x77, 0x03, 0x04, 0x4f, 0x63, 0x2f, 0xda, 0xe7, 0x60, 0x80, 0xf4, 0x40, 0x7f, 0x63, 0xc0, 0x05,
	0x36, 0x06, 0x45, 0x39, 0xd0, 0x24, 0x63, 0x6b, 0xd3, 0x81, 0x35, 0x51, 0x1d, 0x1d, 0x82, 0xdd,
	0x36, 0xb4, 0xc7, 0x50, 0xef, 0x60, 0x2d, 0xb4, 0xc8, 0xfe, 0x3b, 0xac, 0xd5, 0x03, 0xc1, 0xd3,
	0x58, 0xf7, 0x45, 0x05, 0xd6, 0x4a, 0x0c, 0x74, 0x13, 0xa2, 0xe9, 0x43, 0xb4, 0x43, 0xe2, 0x48,
	0xff, 0xfc, 0xf0, 0xe7, 0x0b, 0x21, 0xe0, 0x6e, 0x78, 0x67, 0x0a, 0xd9, 0xf6, 0xf7, 0xad, 0x0d,
	0x5d, 0xba, 0x2a, 0xf5, 0xfc, 0xe2, 0xfd, 0xc0, 0xa3, 0x94, 0x7d, 0x42, 0x82, 0x3d, 0xc9, 0x49,
	0x12, 0x2b, 0xb7, 0xcf, 0xa5, 0x9f, 0xd0, 0x7f, 0x60, 0x7b, 0x90, 0xf0, 0x0e, 0xbd, 0x7e, 0xaa,
	0x07, 0x6d, 0x06, 0x4d, 0xa0, 0x3f, 0x4b, 0x52, 0xcd, 0x6a, 0xb7, 0x57, 0xed, 0xb4, 0x2e, 0x20,
	0x85, 0x65, 0x48, 0xb2, 0x54, 0x29, 0xbd, 0xe8, 0x94, 0x2a, 0x52, 0x54, 0x31, 0x49, 0x86, 0x8d,
	0x60, 0x97, 0x04, 0x02, 0x27, 0xfa, 0x1c, 0x4b, 0x29, 0x5b, 0x24, 0x63, 0xea, 0x9a, 0x3d, 0xd5,
	0x07, 0xfc, 0xb6, 0xd3, 0xf3, 0x79, 0x4c, 0x92, 0x63, 0xc3, 0x81, 0x74, 0xf5, 0x16, 0x6f, 0xd1,
	0x8a, 0x34, 0x45, 0xdd, 0xba, 0x3f, 0xb7, 0x6d, 0x70, 0x03, 0x95, 0xfa, 0x49, 0x90, 0xf3, 0x9a,
	0xa0, 0x88, 0x77, 0x1f, 0x1f, 0x83, 0xbb, 0x8e, 0xe1, 0x7a, 0xe0, 0x5a, 0xf9, 0xe3, 0x2c, 0x9f,
	0xa5, 0x4d, 0xdb, 0x4e, 0xe3, 0x3d, 0xd0, 0x97, 0xa6, 0x0f, 0x53, 0x7f, 0x03, 0x59, 0xca, 0xcf,
	0xac, 0x39, 0x0c, 0xb1, 0x23, 0x9d, 0x85, 0x72, 0xc5, 0xc1, 0xb8, 0x8f, 0xf3, 0x75, 0xe6, 0xa6,
	0x2e, 0xef, 0xdd, 0x32, 0x27, 0xf5, 0x5a, 0x48, 0x3d, 0x6a, 0x68, 0x46, 0x6c, 0x82, 0x6b, 0xc6,
	0x9a, 0x62, 0x5e, 0xda, 0x64, 0x2b, 0xc4, 0x31, 0xb6, 0x81, 0xc4, 0xd4, 0xc2, 0xc8, 0x02, 0x4d,
	0x09, 0x5c, 0xf4, 0x9f, 0x01, 0x55, 0xe0, 0xb9, 0x77, 0x67, 0x7a, 0x7f, 0x21, 0xd5, 0x1c, 0x11,
	0x02, 0x59, 0xc5, 0xd6, 0x99, 0x77, 0x46, 0x51, 0x8b, 0x07, 0x9e, 0x16, 0xde, 0x98, 0x83, 0x8a,
	0x31, 0x29, 0x8f, 0xf5, 0xfe, 0x6b, 0x3c, 0x45, 0x99, 0x24, 0xe1, 0x62, 0x4f, 0xe6, 0xa6, 0xeb,
	0x65, 0xc5, 0x23, 0x79, 0x87, 0xba, 0x09, 0x5c, 0x51, 0xd6, 0xec, 0x25, 0x47, 0xe5, 0x19, 0xc9,
	0x0a, 0x43, 0x09, 0xd9, 0xe8, 0xf6, 0x3a, 0xb5, 0x72, 0x0f, 0xce, 0x38, 0x4f, 0x48, 0xbb, 0xda,
	0x69, 0xd4, 0xba, 0xdd, 0xda, 0x45, 0x15, 0x5c, 0xe1, 0xdf, 0xf2, 0x24, 0xbf, 0x90, 0x3e, 0x44,
	0x55, 0xb3, 0x3c, 0x67, 0xb3, 0x53, 0x05, 0xf4, 0x70, 0x69, 0xb9, 0xae, 0x35, 0xe1, 0x49, 0x12,
	0xb2, 0x85, 0x6b, 0xcd, 0xb8, 0x11, 0x7c, 0xb3, 0x92, 0x15, 0x66, 0xa5, 0x4e, 0x02, 0xb1, 0x4b,
	0x65, 0xa1, 0x85, 0x81, 0x27, 0x8a, 0x64, 0x58, 0x6c, 0xdf, 0x10, 0x5c, 0x24, 0x30, 0x9b, 0x0f,
	0x75, 0x92, 0x37, 0xf8, 0xd0, 0x13, 0x92, 0x34, 0xa6, 0x7d, 0x73, 0x3e, 0xf0, 0x32, 0xf4, 0xd6,
	0x42, 0x40, 0xc7, 0x03, 0x07, 0x29, 0xfd, 0x9a, 0x49, 0xa5, 0x6f, 0x96, 0xfa, 0x0a, 0x13, 0xd4,
	0xd4, 0x81, 0xe4, 0x3d, 0xe1, 0x39, 0x67, 0x80, 0x99, 0x64, 0x9f, 0x4b, 0xf7, 0xbc, 0x5e, 0x0c,
	0x80, 0x81, 0xc5, 0x9e, 0x12, 0x82, 0x7b, 0x63, 0x63, 0x74, 0x1c, 0xb3, 0xed, 0xe5, 0x66, 0xe8,
	0x08, 0x24, 0x0f, 0x49, 0x5e, 0xeb, 0x83, 0xd3, 0x6b, 0xfd, 0xb7, 0x5c, 0x7a, 0x88, 0xd2, 0x45,
	0x2e, 0x5d, 0xe2, 0x9d, 0xc1, 0x88, 0x9f, 0x42, 0xec, 0xb7, 0x47, 0xd4, 0xfd, 0x98, 0xfc, 0x08,
	0xe5, 0xef, 0x78, 0xf2, 0xf6, 0xa8, 0xa1, 0x5d, 0x0b, 0xd2, 0x80, 0xaa, 0xfa, 0x9a, 0x97, 0x33,
	0xc7, 0x82, 0x74, 0x19, 0xbb, 0x02, 0xe9, 0xef, 0xc8, 0x1d, 0x90, 0x86, 0x3d, 0x3b, 0xae, 0xf1,
	0x86, 0xe5, 0x16, 0x3e, 0xce, 0xc0, 0x71, 0x0f, 0x83, 0x71, 0x9e, 0x90, 0xb8, 0x9d, 0x2f, 0xc9,
	0x26, 0x4c, 0xf0, 0xc6, 0x32, 0xe7, 0x98, 0x11, 0xd8, 0xd8, 0x3f, 0xc4, 0xb1, 0x7b, 0xc1, 0x58,
	0xaf, 0x5f, 0x30, 0x18, 0x85, 0x90, 0x7c, 0xc0, 0x6b, 0xc1, 0x60, 0x00, 0x5c, 0xb5, 0x40, 0xf2,
	0x80, 0xe4, 0x06, 0xb6, 0x35, 0xb3, 0xe6, 0xde, 0x8e, 0x4c, 0x14, 0xf6, 0x20, 0x4d, 0x85, 0xf5,
	0x05, 0xf2, 0x3f, 0x23, 0xd2, 0x60, 0x3e, 0x99, 0xbc, 0x55, 0x43, 0xf3, 0x4f, 0x70, 0xc8, 0x3d,
	0x6f, 0x08, 0xed, 0x5e, 0x5a, 0x04, 0x62, 0xf0, 0x95, 0x01, 0x49, 0x98, 0x8d, 0x98, 0x0a, 0x8b,
	0x54, 0x59, 0x5f, 0x20, 0x0f, 0xb0, 0x48, 0xbf, 0x9e, 0x71, 0x59, 0x4b, 0xc0, 0x30, 0xd5, 0xeb,
	0x59, 0x20, 0x77, 0x44, 0x0a, 0xe3, 0xc1, 0xf0, 0x24, 0xac, 0xcb, 0x4c, 0x38, 0xee, 0x97, 0x95,
	0xb3, 0x13, 0x51, 0x95, 0x13, 0xb2, 0x89, 0x43, 0x60, 0x53, 0x33, 0x7f, 0xcf, 0x7f, 0x84, 0x83,
	0x76, 0x43, 0x83, 0x5a, 0xd8, 0x2d, 0x6c, 0x7b, 0x6c, 0x4c, 0x47, 0xc2, 0x19, 0xda, 0xc2, 0xb6,
	0x5f, 0xd2, 0x6e, 0xf1, 0xf4, 0x60, 0x90, 0x31, 0xa1, 0xa0, 0x22, 0xa4, 0x9f, 0x23, 0x0c, 0xaa,
	0xd1, 0x6e, 0x51, 0xc1, 0xaf, 0xc9, 0x16, 0x4d, 0x4a, 0x23, 0x8a, 0xb6, 0x42, 0x8b, 0xb9, 0x38,
	0xee, 0xbe, 0x37, 0x8e, 0x4b, 0x88, 0xeb, 0xe1, 0xd0, 0x29, 0x64, 0x2c, 0xa8, 0xcd, 0x06, 0xf3,
	0xbe, 0xb7, 0xbb, 0xf9, 0xc2, 0x50, 0x90, 0x68, 0x33, 0x01, 0xc1, 0xe2, 0xa6, 0xed, 0x39, 0xd8,
	0x1b, 0xc1, 0xe2, 0xf5, 0x4e, 0x53, 0x30, 0xdf, 0x44, 0x9f, 0x40, 0xd2, 0x09, 0xef, 0xe9, 0x4a,
	0x30, 0x5f, 0x03, 0xfb, 0xc5, 0x4d, 0xc1, 0xf4, 0x93, 0x37, 0xde, 0xf4, 0xd7, 0xc2, 0xf4, 0x8d,
	0x8b, 0xa6, 0xe0, 0x28, 0x33, 0x0b, 0xb0, 0xd5, 0x74, 0xc4, 0x65, 0xdf, 0x0a, 0x8e, 0xd2, 0x66,
	0x7d, 0x81, 0xfc, 0x33, 0x92, 0x41, 0xac, 0xc5, 0xa5, 0x7f, 0x40, 0xe9, 0x1d, 0x5f, 0xfa, 0x2a,
	0x1c, 0x76, 0x3f, 0x03, 0x59, 0x5b, 0x37, 0xe7, 0x5c, 0xf6, 0x2f, 0x23, 0xa2, 0x70, 0x47, 0xaf,
	0x9f, 0x07, 0xc2, 0x9f, 0x93, 0xec, 0xec, 0xad, 0x3b, 0xf6, 0xef, 0xdc, 0x5f, 0x44, 0x84, 0x8b,
	0xde, 0xc6, 0x3e, 0xe1, 0xbe, 0x85, 0xa6, 0xfe, 0x63, 0xe1, 0xbe, 0x89, 0x13, 0xc3, 0x0e, 0x1d,
	0x63, 0x34, 0xb1, 0x8c, 0x01, 0x17, 0xfe, 0x13, 0x61, 0x87, 0x5d, 0xd6, 0x27, 0xca, 0x5b, 0x43,
	0x37, 0x88, 0x4f, 0x7f, 0x2a, 0xca, 0xb3, 0x3e, 0xc1, 0x22, 0x8e, 0x49, 0xa1, 0x15, 0x93, 0xfe,
	0x33, 0x61, 0x93, 0x5d, 0xda, 0x23, 0x68, 0x0d, 0xe5, 0xe1, 0x98, 0x8b, 0xfe, 0x52, 0xd0, 0xba,
	0xa7, 0x4d, 0x5f, 0x86, 0x3d, 0xb9, 0xe0, 0x8e, 0x6d, 0x1d, 0x40, 0x91, 0xe9, 0xe9, 0xfd, 0xe7,
	0x11, 0xc1, 0x93, 0x7b, 0x5e, 0xb7, 0x10, 0xbc, 0xae, 0x0c, 0x00, 0x74, 0x57, 0x61, 0x5f, 0xf9,
	0x55, 0x44, 0x70, 0x96, 0x57, 0x28, 0x20, 0x38, 0x8b, 0xf2, 0x4b, 0x72, 0xf7, 0xa6, 0x44, 0x00,
	0x48, 0xc4, 0xe9, 0x6b, 0x26, 0xcb, 0x9d, 0x3c, 0x45, 0x6f, 0x4c, 0x0c, 0xdb, 0xb6, 0x6c, 0x4c,
	0xa0, 0x3e, 0x8a, 0x03, 0x88, 0xd9, 0x87, 0xd0, 0xa5, 0x22, 0x5a, 0xa6, 0xf9, 0x3c, 0xc7, 0x08,
	0x81, 0x34, 0xad, 0x6a, 0xd5, 0xa1, 0x61, 0xea, 0x98, 0xce, 0xd3, 0xb4, 0xe4, 0xc6, 0x26, 0x06,
	0xa2, 0x31, 0x6b, 0x2a, 0xdf, 0x92, 0x9c, 0x78, 0xb1, 0x00, 0xb1, 0x1b, 0xa3, 0xa9, 0x05, 0x78,
	0x82, 0x55, 0xeb, 0x11, 0x5e, 0x35, 0x00, 0x26, 0x01, 0x15, 0x4d, 0xba, 0x46, 0x34, 0x04, 0x0f,
	0xeb, 0x64, 0x73, 0x39, 0xcf, 0x80, 0xea, 0x90, 0xc9, 0xd5, 0xd7, 0x38, 0x38, 0xc7, 0x6b, 0x6c,
	0xed, 0xda, 0xf0, 0xf9, 0x8a, 0xa3, 0xa5, 0x65, 0x10, 0x09, 0x29, 0xdf, 0x91, 0xc2, 0x62, 0x16,
	0xda, 0x25, 0x19, 0x1a, 0xb0, 0xa9, 0x53, 0xd0, 0x72, 0x29, 0x12, 0xde, 0xb9, 0xbf, 0x4e, 0x94,
	0xaf, 0xa3, 0x7c, 0x4d, 0x0a, 0x8b, 0x89, 0x69, 0x69, 0x69, 0x40, 0x3a, 0x3c, 0xaf, 0x31, 0xea,
	0x86, 0x0f, 0xfd, 0x9c, 0x14, 0x6f, 0xcc, 0x4d, 0x9b, 0x60, 0x79, 0xc8, 0x9c, 0x00, 0x8d, 0xbd,
	0xc3, 0x50, 0xfe, 0x23, 0x46, 0xb6, 0x57, 0xe6, 0x23, 0xb0, 0xf2, 0x74, 0x3e, 0xe1, 0x41, 0x97,
	0x4d, 0x4f, 0xcd, 0x77, 0x69, 0x68, 0x8e, 0x0a, 0xfd, 0x93, 0xb0, 0xf9, 0x28, 0xd5, 0x30, 0xd3,
	0x06, 0xc1, 0xa9, 0x49, 0x14, 0xc4, 0x0c, 0xd4, 0x31, 0xd6, 0x57, 0xe1, 0x96, 0x2b, 0x04, 0x42,
	0x39, 0xc6, 0xff, 0x64, 0x5e, 0xeb, 0x80, 0x90, 0x4d, 0x76, 0xe2, 0x71, 0x5c, 0x01, 0x2a, 0x26,
	0xde, 0x38, 0xc6, 0xd2, 0x2b, 0xdc, 0x72, 0x85, 0x65, 0x17, 0x6d, 0x49, 0x8c, 0x6c, 0x6b, 0x3e,
	0xc3, 0xd2, 0x10, 0x8f, 0x05, 0xf6, 0xe5, 0xb8, 0xb6, 0x31, 0x60, 0xfc, 0x41, 0x8e, 0x97, 0x81,
	0xac, 0x09, 0x26, 0xca, 0x79, 0x13, 0xf1, 0x96, 0x2b, 0xac, 0xa5, 0x72, 0x10, 0x31, 0x72, 0xbc,
	0xaa, 0x1b, 0x22, 0x2b, 0xc3, 0xe9, 0x2d, 0x2f, 0x62, 0x2c, 0x52, 0x35, 0x10, 0x8d, 0x70, 0xf7,
	0x5c, 0x38, 0x75, 0xab, 0xf0, 0x37, 0x64, 0x43, 0x9f, 0x82, 0xa5, 0x75, 0xac, 0xcd, 0xf2, 0xc7,
	0xca, 0x2d, 0xb9, 0xff, 0xa0, 0x8a, 0x92, 0xa7, 0xc9, 0x4a, 0xf5, 0xac, 0x74, 0x5e, 0xef, 0x29,
	0x9f, 0x91, 0x0d, 0xd6, 0x44, 0x2b, 0x0e, 0xde, 0x08, 0x40, 0x35, 0x4d, 0x12, 0xe5, 0xd2, 0xd9,
	0x19, 0x60, 0x54, 0xfc, 0xf7, 0xbc, 0xd2, 0x6c, 0x42, 0x1d, 0xf2, 0xb7, 0x51, 0x92, 0x13, 0x43,
	0x37, 0x20, 0x52, 0xc7, 0x9a, 0xdb, 0x7d, 0x0f, 0xaf, 0xc2, 0x51, 0x5e, 0x6a, 0x6e, 0x7f, 0x1c,
	0x36, 0x34, 0xdc, 0x36, 0x5a, 0xba, 0xa9, 0xce, 0x6b, 0x63, 0x86, 0xfb, 0xc6, 0x33, 0x39, 0xa2,
	0x75, 0x77, 0xff, 0xb5, 0x3e, 0x1d, 0xe0, 0xf6, 0xf2, 0x01, 0xa8, 0x08, 0x2f, 0x70, 0x50, 0x79,
	0x7e, 0x9a, 0xac, 0x57, 0x2f, 0xaa, 0xf5, 0xca, 0xf3, 0xe0, 0x7e, 0x47, 0xbd, 0xfb, 0x2d, 0x5c,
	0xd9, 0x18, 0x6a, 0x20, 0xdc, 0xed, 0x84, 0xb7, 0x5a, 0x10, 0x08, 0x36, 0xc4, 0x72, 0x6e, 0x8b,
	0x71, 0x45, 0x9c, 0x44, 0x53, 0xfb, 0x96, 0x09, 0x32, 0xe9, 0x30, 0x95, 0xb6, 0x47, 0xa2, 0xb0,
	0x36, 0x58, 0x87, 0xab, 0x01, 0xd6, 0x49, 0x91, 0x78, 0xbd, 0x01, 0xff, 0x45, 0x94, 0x03, 0x22,
	0x2d, 0x81, 0xa0, 0xdd, 0x00, 0x34, 0xd9, 0x34, 0x42, 0xf1, 0x1b, 0x10, 0x3b, 0x3c, 0x38, 0x51,
	0xfe, 0x31, 0x42, 0xe4, 0x15, 0x10, 0x08, 0xce, 0x1b, 0xa3, 0x20, 0x3f, 0x6f, 0xc6, 0x2c, 0xde,
	0x74, 0xde, 0x3e, 0x45, 0xba, 0x71, 0x03, 0x29, 0x96, 0x61, 0xf4, 0x27, 0xe5, 0x7d, 0x72, 0x02,
	0x07, 0x19, 0xc3, 0x96, 0x80, 0x83, 0x8c, 0xe3, 0xb7, 0xcf, 0x41, 0xd2, 0xf8, 0x96, 0x53, 0xfe,
	0x25, 0x42, 0xa4, 0x25, 0xcc, 0xf5, 0x35, 0x49, 0x5b, 0x33, 0xdd, 0x66, 0xf4, 0x49, 0x44, 0xa8,
	0xb1, 0x17, 0x65, 0xbd, 0x86, 0xd6, 0x0c, 0x6a, 0xec, 0xf3, 0x06, 0x9d, 0xbe, 0x6f, 0xe9, 0xc3,
	0x21, 0xea, 0x13, 0x95, 0xf7, 0x89, 0x04, 0x75, 0xda, 0xa5, 0xa9, 0x23, 0x0e, 0x41, 0x2a, 0x02,
	0x4f, 0xce, 0x0b, 0x8f, 0x9f, 0x92, 0xb4, 0x3f, 0x01, 0x35, 0x74, 0xbb, 0xd3, 0xaa, 0xb0, 0xea,
	0x19, 0x26, 0x03, 0x77, 0x84, 0x7f, 0x1a, 0xa5, 0x5f, 0x80, 0x33, 0x56, 0x48, 0x56, 0x80, 0x7b,
	0x12, 0x89, 0x5f, 0x7a, 0x55, 0x25, 0xa3, 0x34, 0x96, 0xfd, 0x85, 0xb6, 0x8c, 0x8d, 0xa1, 0x5f,
	0xc4, 0x1d, 0x2a, 0x2d, 0xb2, 0xb9, 0x0c, 0x03, 0x6f, 0xf7, 0x6a, 0x0c, 0x9d, 0x94, 0x79, 0x75,
	0xc6, 0xf3, 0xe1, 0x90, 0x3b, 0x9e, 0xef, 0x2e, 0x4f, 0xc9, 0xd6, 0x2a, 0x88, 0x08, 0x9e, 0x4a,
	0x9d, 0x54, 0x0d, 0x6a, 0x3b, 0xe5, 0x0f, 0x88, 0xbc, 0x02, 0x16, 0x1e, 0x42, 0xfd, 0x07, 0x79,
	0x83, 0x1b, 0x79, 0xff, 0x46, 0xfc, 0x78, 0xd0, 0x04, 0xa9, 0xd3, 0x68, 0xfd, 0x48, 0xb9, 0x43,
	0xe2, 0xf4, 0x7f, 0x79, 0x83, 0xc0, 0x17, 0x58, 0x88, 0xfe, 0x3d, 0x06, 0x03, 0xfd, 0x7d, 0x94,
	0xc8, 0x2b, 0x20, 0xe4, 0xfb, 0x5f, 0xd9, 0xd0, 0x96, 0x53, 0xe1, 0x5b, 0x04, 0xe9, 0x61, 0xaa,
	0x5f, 0xa9, 0xdc, 0xa9, 0xfc, 0x38, 0xbc, 0x4d, 0xe9, 0xcb, 0x2b, 0x95, 0xf9, 0x16, 0x09, 0x26,
	0x49, 0x19, 0x0e, 0xbf, 0x67, 0x99, 0x50, 0x5c, 0xff, 0xcd, 0x5f, 0xee, 0x1d, 0x92, 0xb1, 0x2d,
	0x0b, 0x22, 0x2e, 0xe0, 0x0e, 0xb8, 0x54, 0x59, 0xe4, 0xca, 0x7e, 0x02, 0x0e, 0xb6, 0xb3, 0x1a,
	0x20, 0x2f, 0x18, 0x46, 0xf9, 0xf7, 0x08, 0x95, 0x5c, 0x85, 0x87, 0xd7, 0x4a, 0x58, 0x4b, 0xa1,
	0x3f, 0xb6, 0x4e, 0xe8, 0x8f, 0xdf, 0x2a, 0xec, 0x65, 0xea, 0x04, 0xcf, 0xd4, 0xca, 0x7f, 0x45,
	0x48, 0x56, 0x80, 0xe4, 0x3b, 0xb4, 0x38, 0x06, 0xbb, 0x32, 0x93, 0xf1, 0xd4, 0x7d, 0x42, 0xad,
	0xad, 0x99, 0xb3, 0xb1, 0x16, 0x58, 0x5b, 0x86, 0xeb, 0xa3, 0xbb, 0x1a, 0xbf, 0x19, 0xf1, 0xc3,
	0x83, 0xaf, 0x4e, 0xe4, 0x0a, 0xc9, 0x50, 0x5f, 0x54, 0x6d, 0x7d, 0x44, 0xef, 0x7d, 0x5c, 0x70,
	0xc9, 0xf0, 0x32, 0xe8, 0x8c, 0x1d, 0x94, 0x3a, 0x2d, 0x94, 0xca, 0x9d, 0x56, 0xb7, 0xab, 0x96,
	0x5f, 0x96, 0x9a, 0xcd, 0x6a, 0xbd, 0x2b, 0x67, 0x49, 0xe4, 0xb5, 0xf7, 0x54, 0x70, 0xa4, 0x9c,
	0x10, 0x12, 0x08, 0x43, 0x66, 0x5e, 0x14, 0x87, 0xbb, 0x2e, 0x93, 0xfc, 0xab, 0x5a, 0xef, 0x65,
	0xad, 0xe9, 0x35, 0x42, 0xa0, 0xfd, 0x7d, 0xb2, 0xb5, 0xaa, 0x74, 0x10, 0x9d, 0x37, 0xe2, 0x65,
	0x5f, 0xe1, 0xb5, 0x27, 0x1c, 0xf1, 0x10, 0x36, 0x04, 0x11, 0x0f, 0xbd, 0x5d, 0x69, 0x93, 0xac,
	0x50, 0x67, 0x3c, 0x22, 0xb2, 0x0f, 0xdd, 0x00, 0x42, 0xd9, 0x86, 0x36, 0xe5, 0x4e, 0xe1, 0x9d,
	0xe9, 0x3e, 0x29, 0x68, 0xe0, 0x88, 0x50, 0x7f, 0x09, 0x2b, 0xf9, 0x41, 0xe0, 0x9f, 0x62, 0x44,
	0x5a, 0x2a, 0x47, 0x4e, 0x48, 0x9c, 0x96, 0x2f, 0xfc, 0x66, 0x2b, 0x37, 0x54, 0x2d, 0xd8, 0xd0,
	0xd0, 0xa1, 0x82, 0x18, 0x9c, 0xd2, 0x48, 0xe7, 0x01, 0x9e, 0xf8, 0x07, 0x00, 0x9e, 0xe8, 0x12,
	0xe0, 0x49, 0x2c, 0x01, 0x1e, 0x84, 0x33, 0x21, 0x78, 0x13, 0x5b, 0x05, 0x6f, 0x92, 0x4b, 0xf0,
	0x26, 0x85, 0x2d, 0x5f, 0xf9, 0x10, 0x24, 0x23, 0xf8, 0xc8, 0xd2, 0xe6, 0x16, 0xe0, 0x07, 0x7d,
	0xac, 0x19, 0x41, 0xde, 0x02, 0xff, 0xe4, 0x95, 0x1d, 0x5e, 0x53, 0xdf, 0x8e, 0x07, 0x84, 0x04,
	0xe6, 0xf0, 0x42, 0x3f, 0x26, 0x83, 0x12, 0xe5, 0xcf, 0x28, 0x9f, 0xd6, 0xed, 0xb5, 0xc0, 0x4b,
	0xba, 0xbd, 0x5a, 0x19, 0x42, 0xde, 0x5a, 0x68, 0xe6, 0x8c, 0xe4, 0x17, 0x8a, 0x40, 0xc9, 0x23,
	0xe7, 0x23, 0xe1, 0x84, 0xf1, 0x63, 0x29, 0xe4, 0x90, 0x14, 0x16, 0x2b, 0x3e, 0x70, 0xb8, 0x09,
	0xc4, 0x0c, 0x33, 0xf4, 0xb8, 0xc5, 0x5e, 0x8e, 0x90, 0xc7, 0x53, 0xfe, 0x3a, 0x42, 0x72, 0x62,
	0xe1, 0x77, 0x8f, 0xe4, 0xa7, 0xfa, 0x48, 0x43, 0x22, 0xc8, 0x31, 0xad, 0x99, 0x5f, 0xc3, 0x1c,
	0xca, 0x5f, 0xf8, 0xb6, 0x65, 0x4c, 0xe5, 0xde, 0xaa, 0xca, 0xf1, 0xc3, 0x70, 0xdd, 0x35, 0x91,
	0x96, 0x4a, 0xcb, 0xe0, 0x48, 0xc5, 0x4c, 0xb4, 0x28, 0xf8, 0x61, 0x2b, 0xd7, 0x49, 0x7e, 0xa1,
	0xec, 0xf4, 0x42, 0x5a, 0xcc, 0x2b, 0x3e, 0xb6, 0xfc, 0x9a, 0xd5, 0x32, 0xa6, 0x2e, 0x47, 0x35,
	0x90, 0x08, 0x58, 0xa3, 0x50, 0x90, 0xfc, 0x15, 0x40, 0x97, 0xa5, 0x9a, 0xf7, 0xc6, 0x8d, 0x2c,
	0x08, 0x2e, 0xf9, 0xe6, 0x62, 0x19, 0xb4, 0xde, 0xce, 0x6c, 0x92, 0x13, 0xab, 0xe4, 0x2f, 0x16,
	0xf4, 0xd8, 0x5b, 0x55, 0x4b, 0x7f, 0x98, 0x35, 0x9f, 0x11, 0x79, 0x45, 0xa5, 0x0d, 0xb6, 0xf2,
	0xcb, 0x73, 0xdf, 0xad, 0x94, 0xff, 0x8c, 0x92, 0xad, 0x15, 0xf5, 0xf5, 0x12, 0x3c, 0x78, 0xa7,
	0xbc, 0x7c, 0x03, 0x86, 0x78, 0xf7, 0x5c, 0x7d, 0x8f, 0x64, 0x87, 0x23, 0x35, 0x50, 0x33, 0xe9,
	0x43, 0x66, 0xda, 0x75, 0x19, 0xee, 0x4a, 0x85, 0xbb, 0x32, 0x30, 0x6a, 0x08, 0xa5, 0x34, 0xe2,
	0xd2, 0xb4, 0x97, 0xba, 0x8e, 0x4f, 0x00, 0x66, 0x64, 0x28, 0xb9, 0xaa, 0x5f, 0x53, 0x9e, 0x6b,
	0x10, 0x44, 0xc6, 0xbb, 0x5c, 0x2b, 0xa4, 0xfe, 0x33, 0x08, 0x09, 0xe2, 0x57, 0x9a, 0x3d, 0x93,
	0xf7, 0x48, 0xb6, 0xaf, 0xf5, 0xc7, 0xba, 0x8a, 0xa4, 0x9c, 0x23, 0xc4, 0xa1, 0x45, 0x28, 0x91,
	0xe3, 0x50, 0xe2, 0x7f, 0xb6, 0x88, 0xb4, 0xf8, 0xac, 0x1b, 0x22, 0xe9, 0xa3, 0x61, 0x92, 0x9e,
	0x31, 0xf6, 0x1e, 0xbb, 0xcf, 0xe8, 0x85, 0x10, 0x7d, 0xfe, 0xe8, 0x9d, 0xe8, 0xf3, 0xc7, 0x37,
	0x4b, 0xfd, 0x36, 0x7f, 0x29, 0x48, 0x08, 0xe0, 0x7c, 0x51, 0x3b, 0xf6, 0x58, 0x8d, 0x0f, 0x4f,
	0x3e, 0xb9, 0xbf, 0x71, 0x03, 0xb9, 0x9f, 0xf7, 0x9e, 0x07, 0x7e, 0x9d, 0x44, 0xdd, 0xbf, 0x25,
	0x05, 0x3a, 0x40, 0x0d, 0xbd, 0x9d, 0xfc, 0x2f, 0xed, 0xc9, 0x1f, 0x3f, 0xb9, 0x69, 0x35, 0xe1,
	0x21, 0x04, 0xd2, 0x06, 0x2e, 0x48, 0x9f, 0x5a, 0x93, 0x58, 0x0b, 0x2c, 0xbe, 0x75, 0xa6, 0xb0,
	0x75, 0xe1, 0xad, 0xe2, 0x23, 0x6c, 0x5c, 0xa6, 0xee, 0xf7, 0xd6, 0xa4, 0xee, 0xef, 0xae, 0x45,
	0xdd, 0xa7, 0xdf, 0x93, 0xba, 0x7f, 0xfa, 0x01, 0xd4, 0x3d, 0x59, 0x97, 0xba, 0xcf, 0xac, 0x43,
	0xdd, 0x67, 0xd7, 0xa7, 0xee, 0x77, 0xd7, 0xa6, 0xee, 0x8b, 0x6b, 0x50, 0xf7, 0xbf, 0xb5, 0x16,
	0x75, 0x9f, 0x7b, 0x1f, 0xea, 0x3e, 0xff, 0x5e, 0xd4, 0xfd, 0x83, 0xf7, 0xa1, 0xee, 0x0b, 0xef,
	0x49, 0xdd, 0x4b, 0xef, 0x4f, 0xdd, 0x6f, 0xae, 0x4b, 0xdd, 0xcb, 0x6b, 0x52, 0xf7, 0x77, 0xd6,
	0xa3, 0xee, 0x95, 0x35, 0xa8, 0xfb, 0xad, 0xb5, 0xa8, 0xfb, 0x9d, 0xdb, 0xa8, 0x7b, 0x91, 0x5e,
	0xdf, 0x5f, 0x87, 0x5e, 0xff, 0x64, 0x4d, 0x7a, 0xfd, 0xd3, 0xb5, 0xe8, 0xf5, 0x87, 0xef, 0x4e,
	0xaf, 0x7f, 0x7c, 0x0b, 0xbd, 0x7e, 0xbc, 0x4c, 0xaf, 0xdf, 0xfb, 0x31, 0x76, 0xfd, 0x64, 0x15,
	0xbb, 0xbe, 0xfd, 0x63, 0xe4, 0xfa, 0xaa, 0x37, 0xd8, 0x27, 0xef, 0xf1, 0x06, 0xfb, 0xec, 0x96,
	0x37, 0xd8, 0x4f, 0x3c, 0x28, 0x1c, 0x11, 0x6c, 0x79, 0x71, 0xb8, 0xf0, 0xeb, 0xa8, 0xff, 0x8e,
	0x93, 0x74, 0x90, 0xac, 0x52, 0x24, 0xde, 0x6c, 0x35, 0xab, 0x80, 0x7c, 0x08, 0xd9, 0x28, 0x3d,
	0xef, 0x5e, 0x94, 0xea, 0xd2, 0x47, 0xf4, 0x27, 0x13, 0xa5, 0x72, 0xf9, 0xbc, 0x53, 0x2a, 0x7f,
	0x0f, 0x40, 0x88, 0xf6, 0x74, 0x5e, 0xd0, 0x0a, 0x61, 0x9f, 0xca, 0x3f, 0x6f, 0xd6, 0xeb, 0x52,
	0x94, 0xb6, 0x96, 0x5b, 0xcd, 0x72, 0xa9, 0x27, 0xc5, 0x20, 0xdf, 0x48, 0xf0, 0x7f, 0xaf, 0x43,
	0xcb, 0x85, 0x8b, 0xaa, 0x5a, 0x87, 0xba, 0x53, 0xfa, 0x18, 0x70, 0x5e, 0x06, 0x5a, 0x2f, 0x5a,
	0xf5, 0xf3, 0x5e, 0xad, 0xd5, 0x94, 0xe2, 0x74, 0x70, 0xa5, 0xd4, 0x2b, 0x49, 0xf4, 0xa7, 0x07,
	0xb9, 0x4a, 0x35, 0xdc, 0xf9, 0x29, 0xc2, 0xb0, 0x4e, 0xab, 0xdd, 0x3a, 0xef, 0x49, 0x1b, 0xb4,
	0xfe, 0xa8, 0x9c, 0x37, 0x1a, 0xdf, 0xab, 0x28, 0xff, 0x88, 0x56, 0xae, 0xd5, 0xf3, 0x72, 0xbd,
	0x56, 0xa9, 0x96, 0x9a, 0x6c, 0xfa, 0x24, 0x1d, 0x50, 0xad, 0xf7, 0x5e, 0xd5, 0xba, 0x55, 0xe9,
	0x1e, 0xad, 0x5c, 0xaa, 0xbf, 0x68, 0x4b, 0x9f, 0xd0, 0xd6, 0xb3, 0x7a, 0xa9, 0xd7, 0xab, 0x36,
	0xa5, 0x14, 0x94, 0x07, 0x69, 0x1a, 0x9b, 0xd8, 0x2c, 0x69, 0xaa, 0x10, 0x7e, 0xc2, 0x1a, 0x6d,
	0x58, 0x86, 0xd0, 0x65, 0xa0, 0x1a, 0x7e, 0xc1, 0x35, 0xbe, 0x4f, 0xf7, 0x54, 0x6b, 0x1c, 0x97,
	0x5b, 0x75, 0x29, 0x43, 0xfb, 0x6a, 0x8d, 0x12, 0xf4, 0xe1, 0xe0, 0x2c, 0x55, 0xb9, 0xd6, 0x3c,
	0x6b, 0xbd, 0x28, 0xd5, 0xb8, 0x06, 0x39, 0xd6, 0xd4, 0xac, 0x76, 0x54, 0xca, 0xa5, 0x9d, 0x97,
	0x7b, 0x52, 0x9e, 0xea, 0x01, 0xd7, 0x5f, 0x2a, 0xd0, 0xb5, 0x1a, 0xd5, 0x46, 0xab, 0xc3, 0xb7,
	0xf0, 0x00, 0x2a, 0xb2, 0x7b, 0x0d, 0xc0, 0x98, 0xb5, 0x66, 0xab, 0x51, 0x2b, 0xd5, 0x61, 0x8a,
	0x17, 0x35, 0x5a, 0x5c, 0xb1, 0xb9, 0x24, 0xac, 0xc1, 0x2e, 0x9a, 0x92, 0x42, 0x37, 0xd0, 0x6e,
	0xb5, 0xea, 0xa0, 0x96, 0xb4, 0x49, 0x31, 0x68, 0xbb, 0xf5, 0xaa, 0xda, 0x91, 0x76, 0xa9, 0xf1,
	0x3a, 0xd5, 0xfa, 0xb9, 0x24, 0x53, 0x89, 0x6e, 0xed, 0x45, 0xa3, 0x55, 0xab, 0x48, 0x5b, 0x50,
	0x31, 0xef, 0xf2, 0x0f, 0x95, 0xd5, 0xfb, 0x55, 0x38, 0x87, 0x56, 0xfb, 0x7b, 0x36, 0xef, 0x1e,
	0x13, 0xae, 0x57, 0x9b, 0xe5, 0xaa, 0xf4, 0x04, 0x3f, 0x5a, 0x67, 0x3d, 0x7a, 0x94, 0xdb, 0x00,
	0x1b, 0xb2, 0xfc, 0x83, 0xc9, 0xee, 0xd0, 0xd5, 0xba, 0xed, 0x7a, 0xad, 0x27, 0xdd, 0xc1, 0x7f,
	0xeb, 0x35, 0x18, 0xf4, 0x98, 0x2e, 0xdc, 0x2b, 0x35, 0x5f, 0x4a, 0x77, 0xe9, 0x9e, 0x5e, 0xd5,
	0x9a, 0x95, 0xd6, 0x2b, 0xb6, 0xa7, 0x22, 0xb5, 0x6f, 0xef, 0x65, 0xa7, 0xda, 0x7d, 0xd9, 0xaa,
	0x57, 0xa4, 0x87, 0x6b, 0xfd, 0x42, 0xe3, 0xff, 0x92, 0x00, 0xf1, 0x0e, 0xd7, 0xf8, 0x8d, 0x86,
	0xc8, 0x0d, 0xc5, 0x38, 0x57, 0x98, 0xa2, 0x9c, 0x0e, 0x52, 0x43, 0xf1, 0xdb, 0xa8, 0xa1, 0xc4,
	0x3a, 0xd4, 0xd0, 0xc6, 0xad, 0xc2, 0x9c, 0x36, 0xf0, 0xc9, 0x3b, 0xd0, 0x8b, 0xd5, 0xfa, 0x88,
	0xc7, 0x53, 0xe2, 0xf3, 0x46, 0x7a, 0xf9, 0x79, 0x83, 0x78, 0x4d, 0x1e, 0x6d, 0x91, 0x11, 0x68,
	0x8b, 0x45, 0x9b, 0x2c, 0xd1, 0x16, 0x4b, 0x2c, 0x78, 0x36, 0xc0, 0xed, 0x22, 0x29, 0x95, 0x5b,
	0x22, 0xa5, 0xf2, 0x8b, 0xa4, 0x54, 0x21, 0x44, 0x4a, 0x21, 0x9d, 0x74, 0xc7, 0x93, 0x08, 0xca,
	0x15, 0x49, 0x2c, 0x57, 0x36, 0x83, 0x82, 0x3d, 0x45, 0xcb, 0x15, 0xac, 0x56, 0x64, 0x94, 0x81,
	0x02, 0x06, 0xab, 0x15, 0x5c, 0x7d, 0x0b, 0x2d, 0x41, 0x7f, 0x21, 0x0c, 0xda, 0x62, 0xcb, 0xf6,
	0x72, 0xad, 0xb2, 0x13, 0x2e, 0x06, 0x7c, 0xe0, 0x7c, 0x7c, 0x03, 0x70, 0x0e, 0x03, 0xdd, 0x9f,
	0xad, 0x04, 0xba, 0x5f, 0xf0, 0xd6, 0x10, 0xcb, 0x7a, 0xe2, 0xad, 0xfa, 0x00, 0x80, 0x98, 0x0e,
	0x1e, 0x11, 0xae, 0x79, 0xbe, 0x0c, 0x6c, 0xc7, 0xbb, 0x85, 0x92, 0xe8, 0xab, 0x70, 0x77, 0x81,
	0x8f, 0xf6, 0xcb, 0xa2, 0x9f, 0x87, 0xca, 0xa2, 0x5d, 0xd6, 0x1d, 0x2e, 0x8d, 0x4e, 0xbd, 0x85,
	0xf7, 0xe0, 0xc4, 0x68, 0x9f, 0x5f, 0x1e, 0x7d, 0x13, 0x2a, 0x8f, 0x64, 0x92, 0xa4, 0x64, 0x2e,
	0x7d, 0x57, 0xf8, 0x9d, 0xe0, 0x37, 0x79, 0x59, 0xda, 0xe6, 0x53, 0x60, 0xbf, 0xeb, 0x75, 0x88,
	0x84, 0xf0, 0xb7, 0x5e, 0xb3, 0x40, 0x08, 0x7f, 0xe7, 0xb5, 0x3e, 0x20, 0x79, 0xce, 0x2a, 0x7b,
	0xa5, 0xd7, 0xef, 0x2d, 0x90, 0xcb, 0xa1, 0xb7, 0xc7, 0x92, 0xe7, 0x95, 0x5f, 0xae, 0x82, 0x7b,
	0xbf, 0x4e, 0xfe, 0x18, 0xde, 0x5b, 0x9b, 0x51, 0x7a, 0x45, 0xf2, 0x0b, 0x8f, 0xff, 0x9f, 0x90,
	0x0d, 0xff, 0x99, 0xe6, 0xb6, 0x0b, 0x08, 0xfb, 0xe2, 0x96, 0x61, 0x15, 0xd3, 0x40, 0xa0, 0x08,
	0x9f, 0xdd, 0x87, 0x90, 0x89, 0x3f, 0xcd, 0x82, 0x10, 0x06, 0x19, 0xa9, 0xd6, 0x64, 0xef, 0x4a,
	0xf4, 0x27, 0x75, 0x52, 0xe4, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf1, 0x4a, 0xf2, 0x53, 0x47,
	0x2f, 0x00, 0x00,
}
